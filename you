local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer

-- Переменные состояния
local isActive = false
local currentPlot = nil
local currentConnections = {}
local isFloating = false
local floatConnection = nil
local scriptActive = true
local flightEnabled = false
local originalProperties = {}
local originalAnchoredState = false
local targetZ = nil
local isMovingToSmallerZ = false

-- Создаем интерфейс
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FlightControl"
screenGui.Parent = CoreGui

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 250, 0, 120)
frame.Position = UDim2.new(0.5, -125, 0.1, 0)
frame.AnchorPoint = Vector2.new(0.5, 0)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BackgroundTransparency = 0.3
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 8)
uiCorner.Parent = frame

local title = Instance.new("TextLabel")
title.Text = "ПОЛЕТ К SPAWN"
title.Size = UDim2.new(1, 0, 0, 25)
title.Position = UDim2.new(0, 0, 0, 5)
title.BackgroundTransparency = 1
title.TextColor3 = Color3.fromRGB(200, 200, 200)
title.Font = Enum.Font.GothamBold
title.TextSize = 14
title.TextXAlignment = Enum.TextXAlignment.Center

local flightToggle = Instance.new("TextButton")
flightToggle.Size = UDim2.new(0, 80, 0, 25)
flightToggle.Position = UDim2.new(0.1, 0, 0.3, 0)
flightToggle.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
flightToggle.Text = "ВЫКЛ"
flightToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
flightToggle.Font = Enum.Font.GothamBold
flightToggle.TextSize = 12

local statusLabel = Instance.new("TextLabel")
statusLabel.Text = "Статус: Ожидание"
statusLabel.Size = UDim2.new(0.9, 0, 0, 20)
statusLabel.Position = UDim2.new(0.05, 0, 0.6, 0)
statusLabel.BackgroundTransparency = 1
statusLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 12
statusLabel.TextXAlignment = Enum.TextXAlignment.Left

local closeLabel = Instance.new("TextLabel")
closeLabel.Text = "F2 - выключить | Down - отмена"
closeLabel.Size = UDim2.new(0.9, 0, 0, 15)
closeLabel.Position = UDim2.new(0.05, 0, 0.8, 0)
closeLabel.BackgroundTransparency = 1
closeLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
closeLabel.Font = Enum.Font.Gotham
closeLabel.TextSize = 10
closeLabel.TextXAlignment = Enum.TextXAlignment.Left

-- Иерархия объектов
title.Parent = frame
flightToggle.Parent = frame
statusLabel.Parent = frame
closeLabel.Parent = frame
uiCorner.Parent = frame
frame.Parent = screenGui

-- Функции для работы с прозрачностью и CanCollide
local function setPlotTransparency(transparencyValue)
    if not currentPlot then return false end
    
    originalProperties = {}
    
    local function processObject(obj)
        if obj:IsA("BasePart") then
            originalProperties[obj] = {
                Transparency = obj.Transparency,
                CanCollide = obj.CanCollide
            }
            
            obj.CanCollide = false
            
            if obj.Name == "FakeRootPart" or obj.Name == "VfxInstance" then
                obj.Transparency = 1
            elseif obj.Name == "Hitbox" and obj.Parent and obj.Parent.Name == "Claim" then
                obj.Transparency = 1
            elseif obj.Name == "Spawn" then
                -- Не изменяем прозрачность Spawn
            else
                obj.Transparency = transparencyValue
            end
        end
    end
    
    local function recurse(model)
        for _, child in ipairs(model:GetChildren()) do
            if child:IsA("Model") or child:IsA("Folder") then
                recurse(child)
            else
                processObject(child)
            end
        end
    end
    
    recurse(currentPlot)
    return true
end

local function restorePlotTransparency()
    if not currentPlot then return false end
    
    for obj, properties in pairs(originalProperties) do
        if obj and obj.Parent then
            obj.Transparency = properties.Transparency
            obj.CanCollide = properties.CanCollide
        end
    end
    
    originalProperties = {}
    return true
end

-- Основные функции
local function findNearestPlot()
    local plots = workspace.Plots:GetChildren()
    local character = player.Character
    if not character or not character.PrimaryPart then return nil end
    
    local playerPosition = character.PrimaryPart.Position
    local nearestPlot = nil
    local shortestDistance = math.huge
    
    for _, plot in ipairs(plots) do
        if plot:IsA("Model") and plot.PrimaryPart then
            local distance = (playerPosition - plot.PrimaryPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestPlot = plot
            end
        end
    end
    
    return nearestPlot
end

local function findNearestSpawn()
    if not currentPlot then return nil end
    
    local animalPodiums = currentPlot:FindFirstChild("AnimalPodiums")
    if not animalPodiums then return nil end
    
    local character = player.Character
    if not character or not character.PrimaryPart then return nil end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return nil end
    
    local rootPart = humanoid.RootPart
    if not rootPart then return nil end
    
    local playerPosition = rootPart.Position
    local nearestSpawn = nil
    local shortestDistance = math.huge
    
    local zCoordinatePairs = {
        {197.60662841796875, 243.60662841796875},
        {-123.39336395263672, -77.3933695263672},
        {136.60687255859375, 90.6064122314453},
        {-13.39263153076172, -77.39263153076172},
        {197.60736083984375, 243.6076083984375},
        {-163.39336395263672, 29.60736846923828},
        {90.60736846923828, 136.6073608398437},
        {29.60663604736328, -16.39336395263672}
    }
    
    local playerHeight = rootPart.Position.Y
    local skipLowPodiums = playerHeight > 11
    
    for i = 11, 20 do
        if skipLowPodiums and i <= 18 then
            continue
        end
        
        local podium = animalPodiums:FindFirstChild(tostring(i))
        if podium then
            local base = podium:FindFirstChild("Base")
            if base then
                local spawn = base:FindFirstChild("Spawn")
                if spawn then
                    local spawnZ = spawn.Position.Z
                    
                    -- Находим пару координат для этого спавна
                    local targetPair = nil
                    for _, pair in ipairs(zCoordinatePairs) do
                        local dist1 = math.abs(spawnZ - pair[1])
                        local dist2 = math.abs(spawnZ - pair[2])
                        
                        if dist1 < 10 or dist2 < 10 then
                            targetPair = pair
                            break
                        end
                    end
                    
                    if targetPair then
                        -- Проверяем обе координаты из пары и выбираем ближайшую
                        local targetZ1 = targetPair[1]
                        local targetZ2 = targetPair[2]
                        
                        local distanceToZ1 = math.abs(playerPosition.Z - targetZ1)
                        local distanceToZ2 = math.abs(playerPosition.Z - targetZ2)
                        
                        -- Выбираем ближайшую Z-координату
                        local finalTargetZ = distanceToZ1 < distanceToZ2 and targetZ1 or targetZ2
                        
                        local targetPosition = Vector3.new(
                            spawn.Position.X,
                            spawn.Position.Y - 3,
                            finalTargetZ
                        )
                        
                        local distance = (playerPosition - targetPosition).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            nearestSpawn = targetPosition
                            targetZ = finalTargetZ
                            isMovingToSmallerZ = (finalTargetZ == targetZ1 and targetZ1 < targetZ2) or (finalTargetZ == targetZ2 and targetZ2 < targetZ1)
                        end
                    else
                        -- Если не нашли подходящую пару, используем оригинальную Z спавна
                        local targetPosition = Vector3.new(
                            spawn.Position.X,
                            spawn.Position.Y - 3,
                            spawn.Position.Z
                        )
                        
                        local distance = (playerPosition - targetPosition).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            nearestSpawn = targetPosition
                            targetZ = spawn.Position.Z
                            isMovingToSmallerZ = false
                        end
                    end
                end
            end
        end
    end
    
    return nearestSpawn
end

local function calculateLookDirection(currentPosition, targetPosition, targetZValue)
    -- Определяем направление взгляда в зависимости от целевой Z координаты
    local direction
    
    -- Если летим к меньшей Z координате, смотрим в отрицательном направлении Z
    -- Если к большей Z координате, смотрим в положительном направлении Z
    if targetZValue then
        local currentZ = currentPosition.Z
        if currentZ > targetZValue then
            -- Летим к меньшей Z, смотрим назад (отрицательное направление Z)
            direction = Vector3.new(0, 0, -1)
        else
            -- Летим к большей Z, смотрим вперед (положительное направление Z)
            direction = Vector3.new(0, 0, 1)
        end
    else
        -- Если targetZ не определен, используем направление к цели
        direction = (targetPosition - currentPosition).Unit
    end
    
    return direction
end

local function smoothFlyToTarget(targetPosition)
    local character = player.Character
    if not character or not character.PrimaryPart then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    -- Сохраняем исходное состояние Anchored
    originalAnchoredState = character.PrimaryPart.Anchored
    
    -- НЕ включаем PlatformStand - чтобы анимации работали
    isFloating = true
    
    statusLabel.Text = "Статус: Полёт..."
    
    local connection
    connection = RunService.Heartbeat:Connect(function()
        if not character or not character.PrimaryPart or not isFloating then
            connection:Disconnect()
            return
        end
        
        local currentPosition = character.PrimaryPart.Position
        local distanceToTarget = (targetPosition - currentPosition).Magnitude
        
        -- Корректируем конечную позицию если летим к меньшей Z
        local adjustedTargetPosition = targetPosition
        if isMovingToSmallerZ then
            adjustedTargetPosition = Vector3.new(
                targetPosition.X,
                targetPosition.Y,
                targetPosition.Z + 0.5 -- Не долетаем на 0.5 studs
            )
        end
        
        local adjustedDistanceToTarget = (adjustedTargetPosition - currentPosition).Magnitude
        
        -- Если достигли скорректированной цели, устанавливаем Anchored
        if adjustedDistanceToTarget <= 0.1 then
            connection:Disconnect()
            statusLabel.Text = "Статус: Зафиксирован (Down - отмена)"
            
            -- Устанавливаем Anchored только когда прилетели
            character.PrimaryPart.Anchored = true
            character.PrimaryPart.Velocity = Vector3.new(0, 0, 0)
            character.PrimaryPart.RotVelocity = Vector3.new(0, 0, 0)
            
            return
        end
        
        -- Постоянная скорость 20
        local direction = (adjustedTargetPosition - currentPosition).Unit
        local speed = 20
        
        -- Применяем скорость
        character.PrimaryPart.Velocity = direction * speed
        
        -- Поворачиваем персонажа в сторону движения к Z координате
        local lookDirection = calculateLookDirection(currentPosition, targetPosition, targetZ)
        if lookDirection then
            -- Устанавливаем поворот персонажа
            character.PrimaryPart.CFrame = CFrame.new(
                character.PrimaryPart.Position,
                character.PrimaryPart.Position + lookDirection
            )
        end
        
        -- Точная корректировка высоты для точного приземления
        local heightDiff = adjustedTargetPosition.Y - currentPosition.Y
        if math.abs(heightDiff) > 0.5 then
            character.PrimaryPart.Velocity = Vector3.new(
                character.PrimaryPart.Velocity.X,
                heightDiff * 3,
                character.PrimaryPart.Velocity.Z
            )
        end
        
        statusLabel.Text = string.format("Статус: Полёт... (%.1m)", adjustedDistanceToTarget)
    end)
    
    table.insert(currentConnections, connection)
    return true
end

local function deactivateFlightMode()
    isFloating = false
    targetZ = nil
    isMovingToSmallerZ = false
    
    -- Восстанавливаем прозрачность и CanCollide для plot
    restorePlotTransparency()
    
    local character = player.Character
    if character and character.PrimaryPart then
        -- Восстанавливаем исходное состояние Anchored
        character.PrimaryPart.Anchored = originalAnchoredState
        
        -- Сбрасываем Velocity для нормального падения
        if not character.PrimaryPart.Anchored then
            character.PrimaryPart.Velocity = Vector3.new(0, -10, 0)
        end
        character.PrimaryPart.RotVelocity = Vector3.new(0, 0, 0)
    end
    
    for _, connection in ipairs(currentConnections) do
        pcall(function() connection:Disconnect() end)
    end
    currentConnections = {}
    
    isActive = false
    currentPlot = nil
    statusLabel.Text = "Статус: Ожидание"
    return true
end

local function activateFlightToSpawn()
    if not flightEnabled then return false end
    
    currentPlot = findNearestPlot()
    if not currentPlot then
        statusLabel.Text = "Статус: Plot не найден"
        return false
    end
    
    -- Устанавливаем прозрачность и отключаем CanCollide для plot
    setPlotTransparency(0.5)
    
    local nearestSpawn = findNearestSpawn()
    if nearestSpawn then
        statusLabel.Text = "Статус: Летим к ближайшей Z..."
        smoothFlyToTarget(nearestSpawn)
    else
        statusLabel.Text = "Статус: Spawn не найден"
        restorePlotTransparency()
        return false
    end
    
    isActive = true
    return true
end

local function disableScript()
    scriptActive = false
    flightEnabled = false
    deactivateFlightMode()
    screenGui:Destroy()
end

-- Обработчики клавиш
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.F2 then
        disableScript()
    elseif input.KeyCode == Enum.KeyCode.Down and scriptActive and flightEnabled then
        if isActive then deactivateFlightMode() end
    end
end)

-- Переключатель полета
flightToggle.MouseButton1Click:Connect(function()
    flightEnabled = not flightEnabled
    if flightEnabled then
        flightToggle.Text = "ВКЛ"
        flightToggle.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
        statusLabel.Text = "Статус: Активация..."
        
        wait(0.1)
        if not isActive then
            activateFlightToSpawn()
        end
    else
        flightToggle.Text = "ВЫКЛ"
        flightToggle.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
        deactivateFlightMode()
    end
end)
