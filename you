local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer

-- Переменные состояния
local isActive = false
local currentPlot = nil
local currentConnections = {}
local isFloating = false
local floatConnection = nil
local scriptActive = true
local flightEnabled = false
local originalProperties = {} -- Таблица для хранения исходных свойств
local originalAnchoredState = false -- Сохраняем исходное состояние Anchored

-- Переменные для управления полетом
local flySpeed = 50 -- Скорость полета
local isFlying = false
local bodyVelocity = nil

-- Создаем интерфейс
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FlightControl"
screenGui.Parent = CoreGui

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 250, 0, 120)
frame.Position = UDim2.new(0.5, -125, 0.1, 0)
frame.AnchorPoint = Vector2.new(0.5, 0)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BackgroundTransparency = 0.3
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 8)
uiCorner.Parent = frame

local title = Instance.new("TextLabel")
title.Text = "ПОЛЕТ К SPAWN"
title.Size = UDim2.new(1, 0, 0, 25)
title.Position = UDim2.new(0, 0, 0, 5)
title.BackgroundTransparency = 1
title.TextColor3 = Color3.fromRGB(200, 200, 200)
title.Font = Enum.Font.GothamBold
title.TextSize = 14
title.TextXAlignment = Enum.TextXAlignment.Center

local flightToggle = Instance.new("TextButton")
flightToggle.Size = UDim2.new(0, 80, 0, 25)
flightToggle.Position = UDim2.new(0.1, 0, 0.3, 0)
flightToggle.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
flightToggle.Text = "ВЫКЛ"
flightToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
flightToggle.Font = Enum.Font.GothamBold
flightToggle.TextSize = 12

local statusLabel = Instance.new("TextLabel")
statusLabel.Text = "Статус: Ожидание"
statusLabel.Size = UDim2.new(0.9, 0, 0, 20)
statusLabel.Position = UDim2.new(0.05, 0, 0.6, 0)
statusLabel.BackgroundTransparency = 1
statusLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 12
statusLabel.TextXAlignment = Enum.TextXAlignment.Left

local closeLabel = Instance.new("TextLabel")
closeLabel.Text = "F2 - выключить | Down - отмена"
closeLabel.Size = UDim2.new(0.9, 0, 0, 15)
closeLabel.Position = UDim2.new(0.05, 0, 0.8, 0)
closeLabel.BackgroundTransparency = 1
closeLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
closeLabel.Font = Enum.Font.Gotham
closeLabel.TextSize = 10
closeLabel.TextXAlignment = Enum.TextXAlignment.Left

-- Иерархия объектов
title.Parent = frame
flightToggle.Parent = frame
statusLabel.Parent = frame
closeLabel.Parent = frame
uiCorner.Parent = frame
frame.Parent = screenGui

-- Функции для работы с прозрачностью и CanCollide
local function setPlotTransparency(transparencyValue)
    if not currentPlot then return false end
    
    -- Очищаем предыдущие сохраненные свойства
    originalProperties = {}
    
    local function processObject(obj)
        if obj:IsA("BasePart") then -- Обрабатываем все BasePart (Part, MeshPart, etc.)
            -- Сохраняем исходные свойства
            originalProperties[obj] = {
                Transparency = obj.Transparency,
                CanCollide = obj.CanCollide  -- Сохраняем CanCollide вместо CanQuery
            }
            
            -- ОТКЛЮЧАЕМ CanCollide ДЛЯ ВСЕХ ОБЪЕКТОВ (CanQuery не трогаем)
            obj.CanCollide = false
            
            -- Устанавливаем прозрачность в зависимости от типа объекта
            if obj.Name == "FakeRootPart" or obj.Name == "VfxInstance" then
                obj.Transparency = 1
            elseif obj.Name == "Hitbox" and obj.Parent and obj.Parent.Name == "Claim" then
                obj.Transparency = 1
            elseif obj.Name == "Spawn" then
                -- Не изменяем прозрачность Spawn
            else
                obj.Transparency = transparencyValue
            end
        end
    end
    
    -- Рекурсивно обрабатываем все объекты в plot
    local function recurse(model)
        for _, child in ipairs(model:GetChildren()) do
            if child:IsA("Model") or child:IsA("Folder") then
                recurse(child)
            else
                processObject(child)
            end
        end
    end
    
    recurse(currentPlot)
    return true
end

local function restorePlotTransparency()
    if not currentPlot then return false end
    
    -- Восстанавливаем оригинальные свойства
    for obj, properties in pairs(originalProperties) do
        if obj and obj.Parent then
            obj.Transparency = properties.Transparency
            obj.CanCollide = properties.CanCollide  -- Восстанавливаем CanCollide
        end
    end
    
    -- Очищаем таблицу
    originalProperties = {}
    return true
end

-- Основные функции
local function findNearestPlot()
    local plots = workspace.Plots:GetChildren()
    local character = player.Character
    if not character or not character.PrimaryPart then return nil end
    
    local playerPosition = character.PrimaryPart.Position
    local nearestPlot = nil
    local shortestDistance = math.huge
    
    for _, plot in ipairs(plots) do
        if plot:IsA("Model") and plot.PrimaryPart then
            local distance = (playerPosition - plot.PrimaryPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestPlot = plot
            end
        end
    end
    
    return nearestPlot
end

local function findNearestSpawn()
    if not currentPlot then return nil end
    
    local animalPodiums = currentPlot:FindFirstChild("AnimalPodiums")
    if not animalPodiums then return nil end
    
    local character = player.Character
    if not character or not character.PrimaryPart then return nil end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return nil end
    
    local rootPart = humanoid.RootPart
    if not rootPart then return nil end
    
    local playerPosition = rootPart.Position
    local nearestSpawn = nil
    local shortestDistance = math.huge
    
    -- Определяем пары Z-координат
    local zCoordinatePairs = {
        {197.60662841796875, 243.60662841796875},
        {-123.39336395263672, -77.3933695263672},
        {136.60687255859375, 90.6064122314453},
        {-13.39263153076172, -77.39263153076172},
        {197.60736083984375, 243.6076083984375},
        {-163.39336395263672, 29.60736846923828},
        {90.60736846923828, 136.6073608398437},
        {29.60663604736328, -16.39336395263672}
    }
    
    -- Проверяем высоту HumanoidRootPart
    local playerHeight = rootPart.Position.Y
    local skipLowPodiums = playerHeight > 11
    
    for i = 11, 20 do
        -- Пропускаем AnimalPodiums 11-18 если высота больше 11
        if skipLowPodiums and i <= 18 then
            continue
        end
        
        local podium = animalPodiums:FindFirstChild(tostring(i))
        if podium then
            local base = podium:FindFirstChild("Base")
            if base then
                local spawn = base:FindFirstChild("Spawn")
                if spawn then
                    local spawnZ = spawn.Position.Z
                    
                    -- Определяем, к какой паре Z-координат ближе этот Spawn
                    local targetZ = nil
                    for _, pair in ipairs(zCoordinatePairs) do
                        local dist1 = math.abs(spawnZ - pair[1])
                        local dist2 = math.abs(spawnZ - pair[2])
                        
                        -- Если Z спавна близко к одной из координат в паре
                        if dist1 < 10 or dist2 < 10 then
                            -- Выбираем ту Z-координату, которая ближе к текущей позиции игрока
                            if math.abs(playerPosition.Z - pair[1]) < math.abs(playerPosition.Z - pair[2]) then
                                targetZ = pair[1]
                            else
                                targetZ = pair[2]
                            end
                            break
                        end
                    end
                    
                    -- Если нашли подходящую пару координат, используем targetZ
                    local targetPosition
                    if targetZ then
                        targetPosition = Vector3.new(
                            spawn.Position.X,
                            spawn.Position.Y - 4,
                            targetZ
                        )
                    else
                        targetPosition = Vector3.new(
                            spawn.Position.X,
                            spawn.Position.Y - 4,
                            spawn.Position.Z
                        )
                    end
                    
                    local distance = (playerPosition - targetPosition).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        nearestSpawn = targetPosition
                    end
                end
            end
        end
    end
    
    return nearestSpawn
end

-- Функции для управления полетом (Inf Jump стиль)
local function startFlying(targetPosition)
    local character = player.Character
    if not character or not character.PrimaryPart then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    -- Сохраняем исходное состояние Anchored
    originalAnchoredState = character.PrimaryPart.Anchored
    
    humanoid.PlatformStand = true
    isFlying = true
    
    -- Создаем BodyVelocity для управления полетом
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
    bodyVelocity.P = 1000
    bodyVelocity.Parent = character.PrimaryPart
    
    statusLabel.Text = "Статус: Полет..."
    
    local startPosition = character.PrimaryPart.Position
    local direction = (targetPosition - startPosition).Unit
    
    -- Рассчитываем время полета на основе расстояния
    local distance = (targetPosition - startPosition).Magnitude
    local flightTime = distance / flySpeed
    
    local startTime = tick()
    
    local flightConnection
    flightConnection = RunService.Heartbeat:Connect(function()
        if not character or not character.PrimaryPart or not isFlying then
            if flightConnection then flightConnection:Disconnect() end
            return
        end
        
        local elapsed = tick() - startTime
        local progress = math.min(elapsed / flightTime, 1)
        
        -- Вычисляем текущую позицию
        local currentPosition = startPosition + (direction * flySpeed * elapsed)
        
        -- Устанавливаем скорость для движения к цели
        bodyVelocity.Velocity = direction * flySpeed
        
        -- Если достигли цели или прошло достаточно времени
        if progress >= 1 or (character.PrimaryPart.Position - targetPosition).Magnitude <= 3 then
            flightConnection:Disconnect()
            stopFlying()
            landAtTarget(targetPosition)
        end
    end)
    
    table.insert(currentConnections, flightConnection)
    return true
end

local function stopFlying()
    isFlying = false
    if bodyVelocity then
        bodyVelocity:Destroy()
        bodyVelocity = nil
    end
end

local function landAtTarget(targetPosition)
    local character = player.Character
    if not character or not character.PrimaryPart then return false end
    
    statusLabel.Text = "Статус: Зафиксирован (Down - отмена)"
    
    -- Устанавливаем позицию точно на цели
    character.PrimaryPart.CFrame = CFrame.new(targetPosition)
    
    -- Фиксируем персонажа
    character.PrimaryPart.Anchored = true
    character.PrimaryPart.Velocity = Vector3.new(0, 0, 0)
    character.PrimaryPart.RotVelocity = Vector3.new(0, 0, 0)
    
    -- Создаем соединение для поддержания фиксации
    floatConnection = RunService.Heartbeat:Connect(function()
        if not character or not character.PrimaryPart or not isFloating then
            if floatConnection then floatConnection:Disconnect() end
            return
        end
        character.PrimaryPart.Anchored = true
        character.PrimaryPart.Velocity = Vector3.new(0, 0, 0)
        character.PrimaryPart.RotVelocity = Vector3.new(0, 0, 0)
    end)
    
    table.insert(currentConnections, floatConnection)
    isFloating = true
    return true
end

local function deactivateFlightMode()
    isFloating = false
    isFlying = false
    
    -- Останавливаем полет
    stopFlying()
    
    if floatConnection then 
        floatConnection:Disconnect() 
        floatConnection = nil
    end
    
    -- Восстанавливаем прозрачность и CanCollide для plot
    restorePlotTransparency()
    
    local character = player.Character
    if character and character.PrimaryPart then
        -- Восстанавливаем исходное состояние Anchored
        character.PrimaryPart.Anchored = originalAnchoredState
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then 
            humanoid.PlatformStand = false 
        end
        
        -- Даем гравитацию для падения
        if not character.PrimaryPart.Anchored then
            character.PrimaryPart.Velocity = Vector3.new(0, -10, 0)
        end
        character.PrimaryPart.RotVelocity = Vector3.new(0, 0, 0)
    end
    
    for _, connection in ipairs(currentConnections) do
        pcall(function() connection:Disconnect() end)
    end
    currentConnections = {}
    
    isActive = false
    currentPlot = nil
    statusLabel.Text = "Статус: Ожидание"
    return true
end

local function activateFlightToSpawn()
    if not flightEnabled then return false end
    
    currentPlot = findNearestPlot()
    if not currentPlot then
        statusLabel.Text = "Статус: Plot не найден"
        return false
    end
    
    -- Устанавливаем прозрачность и отключаем CanCollide для plot
    setPlotTransparency(0.5)
    
    local nearestSpawn = findNearestSpawn()
    if nearestSpawn then
        startFlying(nearestSpawn)
    else
        statusLabel.Text = "Статус: Spawn не найден"
        restorePlotTransparency() -- Восстанавливаем если Spawn не найден
        return false
    end
    
    isActive = true
    return true
end

local function disableScript()
    scriptActive = false
    flightEnabled = false
    deactivateFlightMode()
    screenGui:Destroy()
end

-- Обработчики клавиш
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.F2 then
        disableScript()
    elseif input.KeyCode == Enum.KeyCode.Down and scriptActive and flightEnabled then
        if isActive then deactivateFlightMode() end
    end
end)

-- Переключатель полета - теперь автоматически поднимает при включении
flightToggle.MouseButton1Click:Connect(function()
    flightEnabled = not flightEnabled
    if flightEnabled then
        flightToggle.Text = "ВКЛ"
        flightToggle.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
        statusLabel.Text = "Статус: Активация..."
        
        -- Автоматически активируем полет при включении
        wait(0.1) -- Небольшая задержка для плавности
        if not isActive then
            activateFlightToSpawn()
        end
    else
        flightToggle.Text = "ВЫКЛ"
        flightToggle.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
        deactivateFlightMode()
    end
end)
