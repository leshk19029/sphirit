--[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
-- Load UI Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/leshk19029/sphirit/refs/heads/main/library"))()

-- Create Main Window
local Window = Library:Window({
    Title = "Snow",
    Desc = "Hub",
    Icon = 105059922903197,
    Theme = "Dark",
    Config = {
        Keybind = Enum.KeyCode.RightControl,
        Size = UDim2.new(0, 500, 0, 400)
    },
    CloseUIButton = {
        Enabled = true,
        Text = "x2zu"
    }
})

-- Speed Boost Module
local SpeedBoostModule = {}
SpeedBoostModule.Enabled = false
SpeedBoostModule.CurrentSpeed = 16
SpeedBoostModule.VelocityConnection = nil
SpeedBoostModule.Player = game:GetService("Players").LocalPlayer

function SpeedBoostModule:Enable()
    local RunService = game:GetService('RunService')
    
    local character = self.Player.Character
    if not character then return end
    
    self:Disable()

    self.VelocityConnection = RunService.Heartbeat:Connect(function()
        if not self.Enabled then return end
        
        character = self.Player.Character
        if not character or not character.Parent then return end
        
        local humanoid = character:FindFirstChild('Humanoid')
        local rootPart = character:FindFirstChild('HumanoidRootPart')
        
        if humanoid and rootPart and humanoid.MoveDirection.Magnitude > 0 then
            local moveDirection = humanoid.MoveDirection
            local velocity = moveDirection * self.CurrentSpeed
            rootPart.Velocity = Vector3.new(velocity.X, rootPart.Velocity.Y, velocity.Z)
        end
    end)
end

function SpeedBoostModule:Disable()
    if self.VelocityConnection then
        self.VelocityConnection:Disconnect()
        self.VelocityConnection = nil
    end
end

function SpeedBoostModule:SetSpeed(speed)
    self.CurrentSpeed = math.clamp(speed, 1, 45)
end

function SpeedBoostModule:SetEnabled(state)
    self.Enabled = state
    if state then
        self:Enable()
    else
        self:Disable()
    end
end

-- Обработка смены персонажа
SpeedBoostModule.Player.CharacterAdded:Connect(function()
    if SpeedBoostModule.Enabled then
        SpeedBoostModule:Disable()
        SpeedBoostModule:Enable()
    end
end)

SpeedBoostModule.Player.CharacterRemoving:Connect(function()
    SpeedBoostModule:Disable()
end)

-- Anti-Effects Function
local AntiEffectsEnabled = false
local AntiEffectsConnections = {}

local function EnableAntiEffects()
    local lighting = game:GetService("Lighting")
    local camera = game:GetService("Workspace").CurrentCamera

    local function checkForDiscoEffect(child)
        if child.Name == "DiscoEffect" then
            child:Destroy()
            
            local blur = lighting:FindFirstChild("Blur")
            if blur then
                blur:Destroy()
            end

            local correction = lighting:FindFirstChild("ColorCCorrection") or Instance.new("ColorCCorrection")
            correction.Parent = lighting
            correction.Enabled = true

            camera.FieldOfView = 70
            
            if not AntiEffectsConnections.FOV then
                AntiEffectsConnections.FOV = camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
                    if camera.FieldOfView ~= 70 then
                        camera.FieldOfView = 70
                    end
                end)
            end
        end
    end

    for _, child in ipairs(lighting:GetChildren()) do
        checkForDiscoEffect(child)
    end

    AntiEffectsConnections.Lighting = lighting.ChildAdded:Connect(checkForDiscoEffect)

    local Players = game:GetService("Players")
    local Lighting = game:GetService("Lighting")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")

    local localPlayer = Players.LocalPlayer
    local playerScripts = localPlayer.PlayerScripts

    local function restoreControls()
        local PlayerModule = require(playerScripts:WaitForChild("PlayerModule"))
        local controls = PlayerModule:GetControls()
        local CharacterController = require(ReplicatedStorage.Controllers.CharacterController)
        local originalMoveFunction = CharacterController.originalMoveFunction
        
        if controls and originalMoveFunction then
            controls.moveFunction = originalMoveFunction
        end
        
        if camera then
            camera.FieldOfView = 70
        end
    end

    local function checkEffects()
        for _, effectName in ipairs({"BeeBlur", "ColorCorrection"}) do
            local effect = Lighting:FindFirstChild(effectName)
            if effect then
                effect:Destroy()
            end
        end
    end

    AntiEffectsConnections.Effects = Lighting.ChildAdded:Connect(function(child)
        if child.Name == "BeeBlur" or child.Name == "ColorCorrection" then
            child:Destroy()
            restoreControls()
        end
    end)

    AntiEffectsConnections.Heartbeat = RunService.Heartbeat:Connect(function()
        checkEffects()
        restoreControls()
    end)

    checkEffects()
    restoreControls()
end

local function DisableAntiEffects()
    for _, connection in pairs(AntiEffectsConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    AntiEffectsConnections = {}
end

-- Wallhack Function
local WallhackEnabled = false
local WallhackHighlights = {}
local WallhackConnections = {}

local function EnableWallhack()
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer

    local function createHighlight(character, player)
        if WallhackHighlights[player] then
            WallhackHighlights[player]:Destroy()
        end
        
        local highlight = Instance.new("Highlight")
        highlight.Name = "Highlight"
        highlight.Adornee = character
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.FillColor = Color3.fromRGB(0, 170, 255)
        highlight.FillTransparency = 0.22
        highlight.OutlineColor = Color3.fromRGB(0, 170, 255)
        highlight.OutlineTransparency = 0.08
        highlight.Archivable = true
        highlight.Parent = character
        
        WallhackHighlights[player] = highlight
    end

    local function onPlayerAdded(player)
        if player == localPlayer then return end
        
        WallhackConnections[player] = player.CharacterAdded:Connect(function(character)
            createHighlight(character, player)
        end)
        
        if player.Character then
            createHighlight(player.Character, player)
        end
    end

    local function onPlayerRemoving(player)
        if WallhackHighlights[player] then
            WallhackHighlights[player]:Destroy()
            WallhackHighlights[player] = nil
        end
        if WallhackConnections[player] then
            WallhackConnections[player]:Disconnect()
            WallhackConnections[player] = nil
        end
    end

    Players.PlayerAdded:Connect(onPlayerAdded)
    Players.PlayerRemoving:Connect(onPlayerRemoving)

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            onPlayerAdded(player)
        end
    end
end

local function DisableWallhack()
    for player, highlight in pairs(WallhackHighlights) do
        if highlight then
            highlight:Destroy()
        end
    end
    WallhackHighlights = {}
    
    for player, connection in pairs(WallhackConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    WallhackConnections = {}
end

-- Timer ESP Function
local TimerESPEnabled = false
local TimerESPTimers = {}
local TimerESPConnections = {}

local function EnableTimerESP()
    local Workspace = game:GetService('Workspace')
    local RunService = game:GetService('RunService')

    local function CalculateYOffset(podiumCount)
        if podiumCount > 18 then return -26.27
        elseif podiumCount > 10 then return -17.27
        else return -8.27 end
    end

    local function CreateTimerDisplay(hitbox, remainingTime)
        if not hitbox or not remainingTime then return end

        if TimerESPTimers[hitbox] then
            local timerData = TimerESPTimers[hitbox]
            if timerData.Billboard then timerData.Billboard:Destroy() end
            if timerData.Part then timerData.Part:Destroy() end
            if timerData.Connection then timerData.Connection:Disconnect() end
            TimerESPTimers[hitbox] = nil
        end

        local plot = hitbox.Parent
        local animalPodiums = plot:FindFirstChild('AnimalPodiums')
        local podiumCount = animalPodiums and #animalPodiums:GetChildren() or 0
        local y_offset = CalculateYOffset(podiumCount)

        local timerPart = Instance.new('Part')
        timerPart.Name = 'TimerPart'
        timerPart.Size = Vector3.new(4, 1, 1)
        timerPart.Transparency = 1
        timerPart.CanCollide = false
        timerPart.Anchored = true
        timerPart.Parent = workspace
        timerPart.CFrame = hitbox.CFrame * CFrame.new(0, y_offset, 0)

        local billboardTimer = Instance.new('BillboardGui')
        billboardTimer.Name = 'TimerDisplay'
        billboardTimer.Size = UDim2.new(5, 0, 2, 0)
        billboardTimer.Adornee = timerPart
        billboardTimer.StudsOffset = Vector3.new(0, 0, 0)
        billboardTimer.AlwaysOnTop = true
        billboardTimer.MaxDistance = 10000
        billboardTimer.Parent = timerPart

        local timerText = Instance.new('TextLabel')
        timerText.Name = 'TimerText'
        timerText.Size = UDim2.new(1, 0, 1, 0)
        timerText.TextSize = 26
        timerText.BackgroundTransparency = 1
        timerText.TextColor3 = Color3.fromRGB(255, 255, 255)
        timerText.TextStrokeColor3 = Color3.new(0, 0, 0)
        timerText.TextStrokeTransparency = 0.1
        timerText.Font = Enum.Font.SciFi
        timerText.TextXAlignment = Enum.TextXAlignment.Center
        timerText.TextYAlignment = Enum.TextYAlignment.Center
        timerText.Text = remainingTime.Text
        timerText.Parent = billboardTimer

        local currentYOffset = y_offset
        local connection = RunService.Heartbeat:Connect(function()
            if hitbox and hitbox.Parent then
                local newPodiumCount = animalPodiums and #animalPodiums:GetChildren() or 0
                local newYOffset = CalculateYOffset(newPodiumCount)
                
                if newYOffset ~= currentYOffset then
                    currentYOffset = newYOffset
                    timerPart.CFrame = hitbox.CFrame * CFrame.new(0, currentYOffset, 0)
                else
                    timerPart.CFrame = hitbox.CFrame * CFrame.new(0, currentYOffset, 0)
                end
            else
                connection:Disconnect()
                if timerPart then timerPart:Destroy() end
                TimerESPTimers[hitbox] = nil
            end
        end)

        TimerESPTimers[hitbox] = {
            Billboard = billboardTimer,
            Part = timerPart,
            Connection = connection,
            TextLabel = timerText,
            CurrentOffset = y_offset
        }

        TimerESPConnections[hitbox] = remainingTime:GetPropertyChangedSignal('Text'):Connect(function()
            local text = remainingTime.Text
            if text == '0s' then
                timerText.Text = 'UNLOCKED'
                timerText.TextColor3 = Color3.fromRGB(0, 255, 0)
            else
                timerText.Text = text
                timerText.TextColor3 = Color3.fromRGB(255, 255, 255)
            end
        end)
    end

    local function SetupPlotTimer(plot)
        if not plot then return end
        local Purchases = plot:FindFirstChild('Purchases')
        if not Purchases then return end
        local Plotblock = Purchases:FindFirstChild('PlotBlock')
        if not Plotblock then return end
        local main = Plotblock:FindFirstChild('Main')
        local hitbox = plot:FindFirstChild('StealHitbox')
        if not main or not hitbox then return end
        local billboardgui = main:FindFirstChild('BillboardGui')
        if not billboardgui then return end
        local remainingTime = billboardgui:FindFirstChild('RemainingTime')
        if not remainingTime then return end

        CreateTimerDisplay(hitbox, remainingTime)
    end

    local function CleanupMissingPlots()
        for hitbox, timerData in pairs(TimerESPTimers) do
            if not hitbox or not hitbox.Parent then
                if timerData.Billboard then timerData.Billboard:Destroy() end
                if timerData.Part then timerData.Part:Destroy() end
                if timerData.Connection then timerData.Connection:Disconnect() end
                TimerESPTimers[hitbox] = nil
            end
        end
    end

    -- Initialize existing plots
    local Plots = Workspace:FindFirstChild('Plots')
    if Plots then
        for _, plot in pairs(Plots:GetChildren()) do
            task.spawn(function()
                SetupPlotTimer(plot)
            end)
        end

        TimerESPConnections.Plots = Plots.ChildAdded:Connect(function(plot)
            task.wait(1)
            SetupPlotTimer(plot)
        end)

        TimerESPConnections.PlotsRemoved = Plots.ChildRemoved:Connect(function(plot)
            CleanupMissingPlots()
        end)
    end

    -- Performance optimization heartbeat
    TimerESPConnections.Heartbeat = RunService.Heartbeat:Connect(function()
        CleanupMissingPlots()
        for hitbox, timerData in pairs(TimerESPTimers) do
            if hitbox and hitbox.Parent and timerData.Part then
                local plot = hitbox.Parent
                local animalPodiums = plot:FindFirstChild('AnimalPodiums')
                local podiumCount = animalPodiums and #animalPodiums:GetChildren() or 0
                local newYOffset = CalculateYOffset(podiumCount)
                
                if newYOffset ~= timerData.CurrentOffset then
                    timerData.CurrentOffset = newYOffset
                    timerData.Part.CFrame = hitbox.CFrame * CFrame.new(0, newYOffset, 0)
                end
            end
        end
    end)
end

local function DisableTimerESP()
    for hitbox, timerData in pairs(TimerESPTimers) do
        if timerData then
            if timerData.Billboard then timerData.Billboard:Destroy() end
            if timerData.Part then timerData.Part:Destroy() end
            if timerData.Connection then timerData.Connection:Disconnect() end
        end
    end
    TimerESPTimers = {}
    
    for _, connection in pairs(TimerESPConnections) do
        if connection then connection:Disconnect() end
    end
    TimerESPConnections = {}
end

-- Nametags ESP Function
local NametagsEnabled = false
local NametagsTags = {}
local NametagsConnections = {}

local function EnableNametags()
    local Players = game:GetService('Players')
    local TextService = game:GetService('TextService')
    local RunService = game:GetService('RunService')

    local function CalculateBackgroundWidth(text)
        local textSize = TextService:GetTextSize(text, 14, Enum.Font.GothamBold, Vector2.new(1000, 22))
        return math.max(60, textSize.X + 20)
    end

    local function CreateNameTag(player)
        if not player.Character then return end
        local head = player.Character:FindFirstChild('Head')
        if not head then return end

        if NametagsTags[player] then
            NametagsTags[player]:Destroy()
        end

        local displayName = player.DisplayName
        local width = CalculateBackgroundWidth(displayName)

        local billboard = Instance.new('BillboardGui')
        billboard.Name = 'Nametag_' .. player.Name
        billboard.Adornee = head
        billboard.Size = UDim2.new(0, width, 0, 18)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.MaxDistance = 500
        billboard.Parent = head

        local background = Instance.new('Frame')
        background.Name = 'Background'
        background.Size = UDim2.new(0, width, 0, 18)
        background.Position = UDim2.new(0.5, -width / 2, 0, 0)
        background.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        background.BackgroundTransparency = 0.25
        background.BorderSizePixel = 0

        local corner = Instance.new('UICorner')
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = background
        background.Parent = billboard

        local nameLabel = Instance.new('TextLabel')
        nameLabel.Name = 'Name'
        nameLabel.Size = UDim2.new(1, -12, 1, 0)
        nameLabel.Position = UDim2.new(0, 6, 0, 0)
        nameLabel.Text = displayName
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.TextSize = 14
        nameLabel.BackgroundTransparency = 1
        nameLabel.TextXAlignment = Enum.TextXAlignment.Center
        nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        nameLabel.TextStrokeTransparency = 0.3
        nameLabel.Parent = billboard

        NametagsTags[player] = billboard

        if not NametagsConnections[player] then
            NametagsConnections[player] = player:GetPropertyChangedSignal('DisplayName'):Connect(function()
                if NametagsTags[player] then
                    local newWidth = CalculateBackgroundWidth(player.DisplayName)
                    nameLabel.Text = player.DisplayName
                    background.Size = UDim2.new(0, newWidth, 0, 18)
                    background.Position = UDim2.new(0.5, -newWidth / 2, 0, 0)
                    billboard.Size = UDim2.new(0, newWidth, 0, 18)
                end
            end)
        end
    end

    local function onPlayerAdded(player)
        if player == Players.LocalPlayer then return end
        
        NametagsConnections[player] = player.CharacterAdded:Connect(function()
            task.wait(1)
            CreateNameTag(player)
        end)
        
        if player.Character then
            CreateNameTag(player)
        end
    end

    Players.PlayerAdded:Connect(onPlayerAdded)
    Players.PlayerRemoving:Connect(function(player)
        if NametagsTags[player] then
            NametagsTags[player]:Destroy()
            NametagsTags[player] = nil
        end
        if NametagsConnections[player] then
            NametagsConnections[player]:Disconnect()
            NametagsConnections[player] = nil
        end
    end)

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            onPlayerAdded(player)
        end
    end

    -- Performance optimized heartbeat
    NametagsConnections.Heartbeat = RunService.Heartbeat:Connect(function()
        for player, nameTag in pairs(NametagsTags) do
            if player.Character and player.Character:FindFirstChild('Head') then
                if nameTag.Adornee ~= player.Character.Head then
                    nameTag.Adornee = player.Character.Head
                end
                nameTag.Enabled = true
            else
                nameTag.Enabled = false
            end
        end
    end)
end

local function DisableNametags()
    for player, tag in pairs(NametagsTags) do
        if tag then tag:Destroy() end
    end
    NametagsTags = {}
    
    for _, connection in pairs(NametagsConnections) do
        if connection then connection:Disconnect() end
    end
    NametagsConnections = {}
end

-- Brainrot ESP Function
local BrainrotESPEnabled = false
local BrainrotESPBillboard = nil
local BrainrotESPConnections = {}

local function EnableBrainrotESP()
    local RunService = game:GetService('RunService')
    local Workspace = game:GetService('Workspace')
    local plot = Workspace.Plots

    local CONFIG = {
        MAX_DISTANCE = 500,
        AUTO_COLOR = true,
        MIN_BRIGHTNESS = 0.7,
        TEXT_STROKE_COLOR = Color3.fromRGB(0, 0, 0),
        TEXT_STROKE_TRANSPARENCY = 0,
        FONT = Enum.Font.TitilliumWeb,
        UPDATE_INTERVAL = 2,
        TEXT_OFFSET_NEAR = 12.0,
        TEXT_OFFSET_FAR = 17.0,
        TEXT_SIZE_NEAR = 36,
        TEXT_SIZE_FAR = 24,
        VALUE_THRESHOLD = 1.1,
        FONT_WEIGHT = Enum.FontWeight.Bold,
        SMOOTHING_FACTOR = 0.2,
    }

    local currentTextSize = CONFIG.TEXT_SIZE_NEAR
    local currentTextOffset = CONFIG.TEXT_OFFSET_NEAR
    local currentColor = Color3.fromRGB(255, 255, 150)

    local function generateLightColor()
        local function getLightComponent()
            return math.random(160, 255) / 255
        end

        local r, g, b = getLightComponent(), getLightComponent(), getLightComponent()
        local brightness = (r + g + b) / 3

        if brightness < CONFIG.MIN_BRIGHTNESS then
            if r < g and r < b then r = CONFIG.MIN_BRIGHTNESS
            elseif g < b then g = CONFIG.MIN_BRIGHTNESS
            else b = CONFIG.MIN_BRIGHTNESS end
        end

        return Color3.new(r, g, b)
    end

    local function formatSalaryText(value)
        if not value then return '0/S' end
        value = tonumber(value) or 0

        if value >= 1000000 then
            return string.format('%.1fM/s', value / 1000000)
        elseif value >= 1000 then
            return string.format('%.1fK/s', value / 1000)
        else
            return string.format('%d/s', math.floor(value))
        end
    end

    local function parseSalaryValue(text)
        if not text then return 0 end
        text = text:upper():gsub('%s+', ''):gsub(',', '')
        local numberPart = text:gsub('[^%d%.]', '')
        local number = tonumber(numberPart) or 0

        if text:find('M/S') then return number * 1000000
        elseif text:find('K/S') then return number * 1000
        else return number end
    end

    local function findMostValuablePet()
        local bestValue = 0
        local bestSpawn, bestName, bestSalary = nil, '', ''

        for _, plotInstance in ipairs(plot:GetChildren()) do
            if not plotInstance:FindFirstChild('PlotSign') or not plotInstance:FindFirstChild('AnimalPodiums') then
                continue
            end

            local isPlayerPlot = plotInstance.PlotSign:FindFirstChild('YourBase') and plotInstance.PlotSign.YourBase.Enabled
            if not isPlayerPlot then
                for _, podium in ipairs(plotInstance.AnimalPodiums:GetChildren()) do
                    if not podium:FindFirstChild('Base') or not podium.Base:FindFirstChild('Spawn') then
                        continue
                    end

                    local spawn = podium.Base.Spawn
                    if not spawn:FindFirstChild('Attachment') then continue end

                    local overhead = spawn.Attachment:FindFirstChild('AnimalOverhead')
                    if overhead and overhead:FindFirstChild('Generation') and overhead:FindFirstChild('DisplayName') then
                        local salaryText = overhead.Generation.Text
                        local value = parseSalaryValue(salaryText)

                        if value > bestValue then
                            bestValue = value
                            bestSpawn = spawn
                            bestName = overhead.DisplayName.Text
                            bestSalary = salaryText
                        end
                    end
                end
            end
        end

        return bestSpawn, bestName, bestSalary, bestValue
    end

    local function smoothLerp(current, target, alpha, deltaTime)
        local smoothing = math.min(alpha * deltaTime * 12, 1)
        return current + (target - current) * smoothing
    end

    local function calculateTextSize(distance)
        local normalizedDistance = math.clamp(distance / CONFIG.MAX_DISTANCE, 0, 1)
        local sizeFactor = 1 - (normalizedDistance * normalizedDistance * 0.8)
        return CONFIG.TEXT_SIZE_NEAR * sizeFactor + CONFIG.TEXT_SIZE_FAR * (1 - sizeFactor)
    end

    local function calculateTextOffset(distance)
        local normalizedDistance = math.clamp(distance / CONFIG.MAX_DISTANCE, 0, 1)
        local offsetFactor = normalizedDistance * normalizedDistance
        return CONFIG.TEXT_OFFSET_NEAR + (CONFIG.TEXT_OFFSET_FAR - CONFIG.TEXT_OFFSET_NEAR) * offsetFactor
    end

    local function createPetBillboard(spawn, name, salaryText)
        if BrainrotESPBillboard and BrainrotESPBillboard.Parent then
            BrainrotESPBillboard:Destroy()
        end
        if not spawn then return end

        if CONFIG.AUTO_COLOR then
            currentColor = generateLightColor()
        end

        local billboard = Instance.new('BillboardGui')
        billboard.Name = 'PetDisplay'
        billboard.Adornee = spawn
        billboard.AlwaysOnTop = true
        billboard.Size = UDim2.new(8, 0, 2, 0)
        billboard.StudsOffset = Vector3.new(0, currentTextOffset, 0)
        billboard.MaxDistance = CONFIG.MAX_DISTANCE
        billboard.Parent = spawn

        local textLabel = Instance.new('TextLabel')
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.Text = name .. '\n' .. formatSalaryText(parseSalaryValue(salaryText))
        textLabel.TextColor3 = currentColor
        textLabel.TextStrokeColor3 = CONFIG.TEXT_STROKE_COLOR
        textLabel.TextStrokeTransparency = CONFIG.TEXT_STROKE_TRANSPARENCY
        textLabel.BackgroundTransparency = 1
        textLabel.TextSize = currentTextSize
        textLabel.Font = CONFIG.FONT
        textLabel.TextScaled = false
        textLabel.TextYAlignment = Enum.TextYAlignment.Center
        textLabel.TextXAlignment = Enum.TextXAlignment.Center
        textLabel.FontFace = Font.new('rbxasset://fonts/families/TitilliumWeb.json', CONFIG.FONT_WEIGHT, Enum.FontStyle.Normal)
        textLabel.Parent = billboard

        BrainrotESPBillboard = billboard

        local lastUpdateTime = os.clock()
        BrainrotESPConnections.Render = RunService.RenderStepped:Connect(function()
            if not billboard or not billboard.Parent then return end

            local camera = Workspace.CurrentCamera
            if not camera then return end

            local currentTime = os.clock()
            local deltaTime = math.min(currentTime - lastUpdateTime, 0.1)
            lastUpdateTime = currentTime

            local distance = (spawn.Position - camera.CFrame.Position).Magnitude
            
            local targetTextSize = calculateTextSize(distance)
            local targetTextOffset = calculateTextOffset(distance)

            currentTextSize = smoothLerp(currentTextSize, targetTextSize, CONFIG.SMOOTHING_FACTOR, deltaTime)
            currentTextOffset = smoothLerp(currentTextOffset, targetTextOffset, CONFIG.SMOOTHING_FACTOR, deltaTime)

            textLabel.TextSize = math.floor(currentTextSize + 0.5)
            billboard.StudsOffset = Vector3.new(0, currentTextOffset, 0)
        end)
    end

    local lastBestValue = 0
    local lastBestSpawn = nil

    BrainrotESPConnections.Main = task.spawn(function()
        while BrainrotESPEnabled do
            task.wait(CONFIG.UPDATE_INTERVAL)
            
            local spawn, name, salary, value = findMostValuablePet()
            if spawn and (spawn ~= lastBestSpawn or value > lastBestValue * CONFIG.VALUE_THRESHOLD) then
                lastBestValue = value
                lastBestSpawn = spawn
                createPetBillboard(spawn, name, salary)
            elseif not spawn then
                if BrainrotESPBillboard then
                    BrainrotESPBillboard:Destroy()
                    BrainrotESPBillboard = nil
                end
                lastBestValue = 0
                lastBestSpawn = nil
            end
        end
    end)
end

local function DisableBrainrotESP()
    if BrainrotESPBillboard then
        BrainrotESPBillboard:Destroy()
        BrainrotESPBillboard = nil
    end
    
    for _, connection in pairs(BrainrotESPConnections) do
        if connection then connection:Disconnect() end
    end
    BrainrotESPConnections = {}
end

-- Web Control Function
local WebControlEnabled = false
local WebControlGUI = nil
local WebControlConnections = {}

local function EnableWebControl()
    local Players = game:GetService('Players')
    local ReplicatedStorage = game:GetService('ReplicatedStorage')
    local RunService = game:GetService('RunService')
    local UserInputService = game:GetService('UserInputService')
    local TweenService = game:GetService('TweenService')

    -- Переменные для хранения состояния
    local originalCharacter = nil
    local originalCameraSettings = {}
    local isControlling = false
    local countdownCoroutine = nil
    local currentTools = {}
    local originalHumanoidState = nil
    local playerList = {}
    local currentPlayerIndex = 1
    local playerListUpdateInterval = 3
    local webSlingerTool = nil
    local controlTime = 8
    local countdownStartTime = 0
    local autoReturnConnection = nil

    -- Цвета для GUI
    local mainColor = Color3.fromRGB(25, 25, 25)
    local accentColor = Color3.fromRGB(0, 255, 140)
    local textColor = Color3.fromRGB(255, 255, 255)
    local borderColor = Color3.fromRGB(50, 50, 50)
    local cancelColor = Color3.fromRGB(255, 100, 100)
    local headerColor = Color3.fromRGB(20, 20, 20)

    -- Функция для получения отображаемого имени игрока (никнейм или логин)
    local function getDisplayName(player)
        return player.DisplayName ~= '' and player.DisplayName or player.Name
    end

    -- Функция для обновления списка игроков
    local function updatePlayerList()
        playerList = {}
        local localPlayer = Players.LocalPlayer

        for _, player in pairs(Players:GetPlayers()) do
            if player ~= localPlayer and player.Character then
                table.insert(playerList, player)
            end
        end

        return playerList
    end

    -- Функция для остановки движения персонажа
    local function stopCharacterMovement(character)
        if not character then
            return
        end

        local humanoid = character:FindFirstChild('Humanoid')
        local humanoidRootPart = character:FindFirstChild('HumanoidRootPart')

        if not humanoid or not humanoidRootPart then
            return
        end

        originalHumanoidState = {
            MoveDirection = humanoid.MoveDirection,
            WalkSpeed = humanoid.WalkSpeed,
        }

        humanoid:MoveTo(humanoidRootPart.Position)
        humanoid.WalkSpeed = 0
    end

    -- Функция для восстановления движения персонажа
    local function restoreCharacterMovement(character)
        if not character or not originalHumanoidState then
            return
        end

        local humanoid = character:FindFirstChild('Humanoid')
        if not humanoid then
            return
        end

        humanoid.WalkSpeed = originalHumanoidState.WalkSpeed
        originalHumanoidState = nil
    end

    -- Функция для изменения WebRopes
    local function modifyWebRopes()
        local workspaceObjects = workspace:GetDescendants()
        local modifiedCount = 0

        for _, object in ipairs(workspaceObjects) do
            if object:IsA('RopeConstraint') and object.Name:lower():find('web') then
                object.Length = 950
                modifiedCount = modifiedCount + 1
            end
        end

        return modifiedCount
    end

    -- Функция для сохранения текущих инструментов
    local function saveCurrentTools()
        local localPlayer = Players.LocalPlayer
        local character = localPlayer.Character
        if not character then
            return
        end

        currentTools = {}
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA('Tool') then
                table.insert(currentTools, tool:Clone())
            end
        end
    end

    -- Функция для восстановления инструментов
    local function restoreTools()
        local localPlayer = Players.LocalPlayer
        local character = localPlayer.Character
        if not character then
            return
        end

        if webSlingerTool and webSlingerTool.Parent == character then
            webSlingerTool.Parent = localPlayer.Backpack
        end

        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA('Tool') then
                tool.Parent = localPlayer.Backpack
            end
        end

        for _, tool in ipairs(currentTools) do
            if tool and tool.Parent then
                local newTool = tool:Clone()
                newTool.Parent = character
            end
        end

        currentTools = {}
        webSlingerTool = nil
    end

    -- Функция для взятия Web Slinger в руки
    local function takeWebSlinger()
        local localPlayer = Players.LocalPlayer
        local character = localPlayer.Character
        local backpack = localPlayer:FindFirstChild('Backpack')
        if not backpack or not character then
            return false
        end

        saveCurrentTools()

        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA('Tool') then
                tool.Parent = backpack
            end
        end

        webSlingerTool = nil
        for _, tool in ipairs(backpack:GetChildren()) do
            if
                tool:IsA('Tool')
                and (
                    tool.Name:lower():find('web')
                    or tool.Name:lower():find('slinger')
                    or tool.Name:lower():find('shooter')
                    or tool.Name:lower():find('swing')
                )
            then
                webSlingerTool = tool
                break
            end
        end

        if not webSlingerTool then
            restoreTools()
            return false
        end

        webSlingerTool.Parent = character
        wait(0.2)

        local humanoid = character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid:EquipTool(webSlingerTool)
            wait(0.3)
            return true
        end

        return false
    end

    -- Функция для проверки расстояния до игрока
    local function isPlayerInRange(targetPlayer, maxDistance)
        local localPlayer = Players.LocalPlayer
        local localCharacter = localPlayer.Character
        if not localCharacter then
            return false
        end

        local localRoot = localCharacter:FindFirstChild('HumanoidRootPart')
        if not localRoot then
            return false
        end

        if not targetPlayer or not targetPlayer.Character then
            return false
        end

        local targetRoot = targetPlayer.Character:FindFirstChild('HumanoidRootPart')
        if not targetRoot then
            return false
        end

        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        return distance <= maxDistance
    end

    -- Функция для поиска ближайшего игрока в радиусе 20 studs
    local function findNearestPlayerInRange()
        local localPlayer = Players.LocalPlayer
        local localCharacter = localPlayer.Character
        if not localCharacter then
            return nil
        end

        local localRoot = localCharacter:FindFirstChild('HumanoidRootPart')
        if not localRoot then
            return nil
        end

        local nearestPlayer = nil
        local shortestDistance = math.huge
        local maxDistance = 20

        for _, player in pairs(Players:GetPlayers()) do
            if player ~= localPlayer and player.Character then
                local character = player.Character
                local humanoidRootPart =
                    character:FindFirstChild('HumanoidRootPart')

                if humanoidRootPart then
                    local distance = (
                        localRoot.Position - humanoidRootPart.Position
                    ).Magnitude
                    if distance < shortestDistance and distance <= maxDistance then
                        shortestDistance = distance
                        nearestPlayer = player
                    end
                end
            end
        end

        return nearestPlayer
    end

    -- Функция для поиска игрока, в которого мы выстрелили
    local function findShotPlayer()
        local localPlayer = Players.LocalPlayer

        for _, player in pairs(Players:GetPlayers()) do
            if player ~= localPlayer and player.Character then
                local character = player.Character
                local humanoid = character:FindFirstChild('Humanoid')

                if humanoid and humanoid.PlatformStand then
                    return player
                end
            end
        end

        return nil
    end

    -- Функция для отключения PlatformStand у цели
    local function disablePlatformStand(targetPlayer)
        if targetPlayer and targetPlayer.Character then
            local humanoid = targetPlayer.Character:FindFirstChild('Humanoid')
            if humanoid then
                humanoid.PlatformStand = false
            end
        end
    end

    -- Функция для сменя персонажа
    local function swapCharacter(targetPlayer)
        local localPlayer = Players.LocalPlayer

        originalCharacter = localPlayer.Character
        originalCameraSettings = {
            CameraType = workspace.CurrentCamera.CameraType,
            CameraSubject = workspace.CurrentCamera.CameraSubject,
        }

        stopCharacterMovement(originalCharacter)
        disablePlatformStand(targetPlayer)
        localPlayer.Character = targetPlayer.Character

        wait(0.5)

        workspace.CurrentCamera.CameraType = originalCameraSettings.CameraType
        if targetPlayer.Character:FindFirstChild('Humanoid') then
            workspace.CurrentCamera.CameraSubject = targetPlayer.Character.Humanoid
        end

        spawn(function()
            modifyWebRopes()
        end)
    end

    -- Функция для возврата к оригинальному персонажу
    local function returnToOriginalCharacter()
        if not originalCharacter then
            return
        end

        local localPlayer = Players.LocalPlayer

        localPlayer.Character = originalCharacter
        restoreCharacterMovement(originalCharacter)

        workspace.CurrentCamera.CameraType = originalCameraSettings.CameraType
        if originalCharacter:FindFirstChild('Humanoid') then
            workspace.CurrentCamera.CameraSubject = originalCharacter.Humanoid
        end

        restoreTools()

        originalCharacter = nil
        originalCameraSettings = {}
        isControlling = false
        countdownStartTime = 0

        -- Отключаем автоматическое возвращение
        if autoReturnConnection then
            autoReturnConnection:Disconnect()
            autoReturnConnection = nil
        end
    end

    -- Функция для автоматического возврата через 10 секунд
    local function setupAutoReturn()
        -- Отключаем предыдущее соединение, если оно есть
        if autoReturnConnection then
            autoReturnConnection:Disconnect()
        end

        -- Устанавливаем новое соединение для автоматического возврата
        autoReturnConnection = game:GetService('RunService').Heartbeat
            :Connect(function()
                if isControlling and originalCharacter then
                    local elapsed = tick() - countdownStartTime
                    if elapsed >= controlTime then
                        -- Автоматически возвращаемся через 10 секунд
                        returnToOriginalCharacter()
                        if controlButton then
                            controlButton.Text = 'Control Player (F)'
                            controlButton.TextColor3 = textColor
                            if controlButtonStroke then
                                controlButtonStroke.Color = borderColor
                            end
                        end
                    end
                end
            end)
    end

    -- Функция для обновления текста кнопки с отсчетом времени
    local function updateControlButtonText()
        if not isControlling or not controlButton then
            return
        end

        local elapsed = tick() - countdownStartTime
        local remaining = math.max(0, controlTime - elapsed)

        if remaining <= 0 then
            controlButton.Text = 'CANCEL (0s)'
            cancelControl()
        else
            controlButton.Text = 'CANCEL (' .. math.ceil(remaining) .. 's)'
        end
    end

    -- Функция для остановки таймера
    local function stopCountdown()
        if countdownCoroutine then
            coroutine.close(countdownCoroutine)
            countdownCoroutine = nil
        end
    end

    -- Функция для отмены контроля
    local function cancelControl()
        if isControlling then
            stopCountdown()
            returnToOriginalCharacter()
            if controlButton then
                controlButton.Text = 'Control Player (F)'
                controlButton.TextColor3 = textColor
                if controlButtonStroke then
                    controlButtonStroke.Color = borderColor
                end
            end
            isControlling = false
        end
    end

    -- Функция AntihitFriend
    local function antihitFriend(targetPlayer)
        if not targetPlayer or not targetPlayer.Character then
            warn('Целевой игрок не найден!')
            return false
        end

        if not isPlayerInRange(targetPlayer, 20) then
            warn('Целевой игрок слишком далеко!')
            return false
        end

        if not takeWebSlinger() then
            warn('Web Slinger не найден!')
            return false
        end

        local targetRoot = targetPlayer.Character:FindFirstChild('HumanoidRootPart')
        if not targetRoot then
            warn('У игрока нет HumanoidRootPart')
            return false
        end

        local Event = ReplicatedStorage.Packages.Net['RE/UseItem']
        Event:FireServer(
            Vector3.new(-450.30258178711, -7.0001068115234, 1.8120102882385),
            targetRoot
        )

        wait(0.5)
        disablePlatformStand(targetPlayer)

        spawn(function()
            modifyWebRopes()
        end)

        return true
    end

    -- Функция для выполнения Control Player
    local function controlPlayer()
        if isControlling then
            cancelControl()
            return
        end

        local nearestPlayer = findNearestPlayerInRange()
        if not nearestPlayer then
            warn('Нет игроков в радиусе 20 studs!')
            return
        end

        if controlButton then
            controlButton.Text = 'Taking Web...'
        end

        if not takeWebSlinger() then
            if controlButton then
                controlButton.Text = 'No Web Slinger found!'
                wait(1)
                controlButton.Text = 'Control Player (F)'
            end
            warn('Web Slinger не найден!')
            return
        end

        if controlButton then
            controlButton.Text = 'Finding target...'
        end

        local targetRoot =
            nearestPlayer.Character:FindFirstChild('HumanoidRootPart')

        if targetRoot then
            if controlButton then
                controlButton.Text = 'Shooting...'
            end

            wait(0.3)

            local Event = ReplicatedStorage.Packages.Net['RE/UseItem']
            Event:FireServer(
                Vector3.new(-450.30258178711, -7.0001068115234, 1.8120102882385),
                targetRoot
            )

            if controlButton then
                controlButton.Text = 'Checking hit...'
            end

            wait(1.5)
            local shotPlayer = findShotPlayer()

            if shotPlayer then
                swapCharacter(shotPlayer)
                isControlling = true
                countdownStartTime = tick()

                if controlButton then
                    controlButton.Text = 'CANCEL (' .. controlTime .. 's)'
                    controlButton.TextColor3 = cancelColor
                    if controlButtonStroke then
                        controlButtonStroke.Color = cancelColor
                    end
                end

                -- Настраиваем автоматическое возвращение через 10 секунд
                setupAutoReturn()

                -- Запускаем отсчет времени для отображения в интерфейсе
                countdownCoroutine = coroutine.create(function()
                    while isControlling do
                        updateControlButtonText()
                        if not isControlling then
                            break
                        end
                        wait(0.1)
                    end
                end)
                coroutine.resume(countdownCoroutine)
            else
                warn('Промах! Не попали в игрока')
                restoreTools()
                if controlButton then
                    controlButton.Text = 'Missed! Try again'
                    wait(1)
                    controlButton.Text = 'Control Player (F)'
                end
            end
        else
            warn('У игрока нет HumanoidRootPart')
            restoreTools()
            if controlButton then
                controlButton.Text = 'Target has no root part'
                wait(1)
                controlButton.Text = 'Control Player (F)'
            end
        end
    end

    -- Создание GUI
    local player = Players.LocalPlayer
    local screenGui = Instance.new('ScreenGui')
    screenGui.Name = 'ControlPlayerMenu'
    screenGui.Parent = player:WaitForChild('PlayerGui')
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Enabled = true -- GUI видимо по умолчанию

    -- Основной контейнер с фоном
    local mainContainer = Instance.new('Frame')
    mainContainer.Name = 'MainContainer'
    mainContainer.Size = UDim2.new(0, 170, 0, 230)
    mainContainer.Position = UDim2.new(0, 14, 0, 25)
    mainContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainContainer.BackgroundTransparency = 0.3
    mainContainer.BorderSizePixel = 0
    mainContainer.Active = true
    mainContainer.Draggable = false
    mainContainer.Parent = screenGui

    local uiCorner = Instance.new('UICorner')
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = mainContainer

    -- Область заголовка сверху
    local headerFrame = Instance.new('Frame')
    headerFrame.Size = UDim2.new(1, 0, 0, 30)
    headerFrame.Position = UDim2.new(0, 0, 0, 0)
    headerFrame.BackgroundColor3 = headerColor
    headerFrame.BackgroundTransparency = 0.2
    headerFrame.BorderSizePixel = 0
    headerFrame.Parent = mainContainer

    local headerCorner = Instance.new('UICorner')
    headerCorner.CornerRadius = UDim.new(0, 8)
    headerCorner.Parent = headerFrame

    -- Текст заголовка
    local headerLabel = Instance.new('TextLabel')
    headerLabel.Size = UDim2.new(1, 0, 1, 0)
    headerLabel.Position = UDim2.new(0, 0, 0, 0)
    headerLabel.BackgroundTransparency = 1
    headerLabel.Text = 'WEB CONTROL'
    headerLabel.TextColor3 = accentColor
    headerLabel.Font = Enum.Font.Code
    headerLabel.TextSize = 16
    headerLabel.TextStrokeTransparency = 0.8
    headerLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    headerLabel.Parent = headerFrame

    -- Внутренний контейнер для элементов
    local contentContainer = Instance.new('Frame')
    contentContainer.Size = UDim2.new(1, 0, 1, -30)
    contentContainer.Position = UDim2.new(0, 0, 0, 30)
    contentContainer.BackgroundTransparency = 1
    contentContainer.Parent = mainContainer

    -- Основная кнопка Control Player
    local controlButton = Instance.new('TextButton')
    controlButton.Size = UDim2.new(0, 150, 0, 40)
    controlButton.Position = UDim2.new(0, 10, 0, 0)
    controlButton.BackgroundColor3 = mainColor
    controlButton.BorderSizePixel = 0
    controlButton.Text = 'Control Player (F)'
    controlButton.TextColor3 = textColor
    controlButton.Font = Enum.Font.Code
    controlButton.TextSize = 14
    controlButton.Parent = contentContainer

    local controlButtonCorner = Instance.new('UICorner')
    controlButtonCorner.CornerRadius = UDim.new(0, 6)
    controlButtonCorner.Parent = controlButton

    local controlButtonStroke = Instance.new('UIStroke')
    controlButtonStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    controlButtonStroke.Color = borderColor
    controlButtonStroke.Thickness = 2
    controlButtonStroke.LineJoinMode = Enum.LineJoinMode.Round
    controlButtonStroke.Parent = controlButton

    -- Кнопка Antihit Friend
    local antihitButton = Instance.new('TextButton')
    antihitButton.Size = UDim2.new(0, 150, 0, 40)
    antihitButton.Position = UDim2.new(0, 10, 0, 50)
    antihitButton.BackgroundColor3 = mainColor
    antihitButton.BorderSizePixel = 0
    antihitButton.Text = 'Antihit Friend (C)'
    antihitButton.TextColor3 = textColor
    antihitButton.Font = Enum.Font.Code
    antihitButton.TextSize = 14
    antihitButton.Parent = contentContainer

    local antihitButtonCorner = Instance.new('UICorner')
    antihitButtonCorner.CornerRadius = UDim.new(0, 6)
    antihitButtonCorner.Parent = antihitButton

    local antihitButtonStroke = Instance.new('UIStroke')
    antihitButtonStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    antihitButtonStroke.Color = borderColor
    antihitButtonStroke.Thickness = 2
    antihitButtonStroke.LineJoinMode = Enum.LineJoinMode.Round
    antihitButtonStroke.Parent = antihitButton

    -- Текст для отображения выбранного игрока
    local playerLabel = Instance.new('TextLabel')
    playerLabel.Size = UDim2.new(0, 150, 0, 30)
    playerLabel.Position = UDim2.new(0, 10, 0, 100)
    playerLabel.BackgroundColor3 = mainColor
    playerLabel.BackgroundTransparency = 0.5
    playerLabel.BorderSizePixel = 0
    playerLabel.Text = 'Players: 0'
    playerLabel.TextColor3 = textColor
    playerLabel.Font = Enum.Font.Code
    playerLabel.TextSize = 12
    playerLabel.Parent = contentContainer

    local playerLabelCorner = Instance.new('UICorner')
    playerLabelCorner.CornerRadius = UDim.new(0, 6)
    playerLabelCorner.Parent = playerLabel

    -- Кнопки для навигации по списку игроков
    local prevButton = Instance.new('TextButton')
    prevButton.Size = UDim2.new(0, 70, 0, 25)
    prevButton.Position = UDim2.new(0, 10, 0, 140)
    prevButton.BackgroundColor3 = mainColor
    prevButton.BorderSizePixel = 0
    prevButton.Text = '◀ Prev'
    prevButton.TextColor3 = textColor
    prevButton.Font = Enum.Font.Code
    prevButton.TextSize = 12
    prevButton.Parent = contentContainer

    local prevButtonCorner = Instance.new('UICorner')
    prevButtonCorner.CornerRadius = UDim.new(0, 6)
    prevButtonCorner.Parent = prevButton

    local nextButton = Instance.new('TextButton')
    nextButton.Size = UDim2.new(0, 70, 0, 25)
    nextButton.Position = UDim2.new(0, 90, 0, 140)
    nextButton.BackgroundColor3 = mainColor
    nextButton.BorderSizePixel = 0
    nextButton.Text = 'Next ▶'
    nextButton.TextColor3 = textColor
    nextButton.Font = Enum.Font.Code
    nextButton.TextSize = 12
    nextButton.Parent = contentContainer

    local nextButtonCorner = Instance.new('UICorner')
    nextButtonCorner.CornerRadius = UDim.new(0, 6)
    nextButtonCorner.Parent = nextButton

    -- ========== ФУНКЦИЯ ПЕРЕТАСКИВАНИЯ ==========
    local function setupDrag(frame)
        local dragging = false
        local dragStart, startPos

        -- Обработка начала перетаскивания
        local function onInputBegan(input)
            if
                input.UserInputType == Enum.UserInputType.MouseButton1
                or input.UserInputType == Enum.UserInputType.Touch
            then
                dragging = true
                dragStart = input.Position
                startPos = frame.Position
            end
        end

        -- Обработка изменения позиции
        local function onInputChanged(input)
            if
                dragging
                and (
                    input.UserInputType == Enum.UserInputType.MouseMovement
                    or input.UserInputType == Enum.UserInputType.Touch
                )
            then
                local delta = input.Position - dragStart
                frame.Position = UDim2.new(
                    startPos.X.Scale,
                    startPos.X.Offset + delta.X,
                    startPos.Y.Scale,
                    startPos.Y.Offset + delta.Y
                )
            end
        end

        -- Обработка окончания перетаскивания
        local function onInputEnded(input)
            if
                input.UserInputType == Enum.UserInputType.MouseButton1
                or input.UserInputType == Enum.UserInputType.Touch
            then
                dragging = false
            end
        end

        -- Подключаем события
        frame.InputBegan:Connect(onInputBegan)
        frame.InputChanged:Connect(onInputChanged)

        UserInputService.InputChanged:Connect(onInputChanged)
        UserInputService.InputEnded:Connect(onInputEnded)
    end

    -- Настройка перетаскивания для основного контейнера
    setupDrag(mainContainer)

    -- Функция для обновления отображения выбранного игрока
    local function updatePlayerDisplay()
        if #playerList == 0 then
            if playerLabel then
                playerLabel.Text = 'No players found'
            end
            return
        end

        local currentPlayer = playerList[currentPlayerIndex]
        if currentPlayer and playerLabel then
            local displayName = getDisplayName(currentPlayer)
            playerLabel.Text = string.format(
                '%d/%d: %s',
                currentPlayerIndex,
                #playerList,
                displayName
            )
        end
    end

    -- Функция для применения эффектов при наведении на кнопки
    local function setupButtonHoverEffects(button)
        if not button then
            return
        end

        button.MouseEnter:Connect(function()
            TweenService:Create(
                button,
                TweenInfo.new(0.2),
                { BackgroundColor3 = Color3.fromRGB(35, 35, 35) }
            ):Play()
        end)

        button.MouseLeave:Connect(function()
            TweenService
                :Create(
                    button,
                    TweenInfo.new(0.2),
                    { BackgroundColor3 = mainColor }
                )
                :Play()
        end)
    end

    -- Применяем эффекты ко всем кнопкам
    setupButtonHoverEffects(controlButton)
    setupButtonHoverEffects(antihitButton)
    setupButtonHoverEffects(prevButton)
    setupButtonHoverEffects(nextButton)

    -- Инициализация списка игроков
    updatePlayerList()
    updatePlayerDisplay()

    -- Запускаем периодическое обновление списка игроков
    WebControlConnections.PlayerUpdate = spawn(function()
        while WebControlEnabled do
            wait(playerListUpdateInterval)
            updatePlayerList()
            if #playerList > 0 then
                currentPlayerIndex = math.min(currentPlayerIndex, #playerList)
                updatePlayerDisplay()
            end
        end
    end)

    -- Обработчики кнопки навигации
    if prevButton then
        prevButton.MouseButton1Click:Connect(function()
            if #playerList > 0 then
                currentPlayerIndex = currentPlayerIndex - 1
                if currentPlayerIndex < 1 then
                    currentPlayerIndex = #playerList
                end
                updatePlayerDisplay()
            end
        end)

        prevButton.TouchTap:Connect(function()
            if #playerList > 0 then
                currentPlayerIndex = currentPlayerIndex - 1
                if currentPlayerIndex < 1 then
                    currentPlayerIndex = #playerList
                end
                updatePlayerDisplay()
            end
        end)
    end

    if nextButton then
        nextButton.MouseButton1Click:Connect(function()
            if #playerList > 0 then
                currentPlayerIndex = currentPlayerIndex + 1
                if currentPlayerIndex > #playerList then
                    currentPlayerIndex = 1
                end
                updatePlayerDisplay()
            end
        end)

        nextButton.TouchTap:Connect(function()
            if #playerList > 0 then
                currentPlayerIndex = currentPlayerIndex + 1
                if currentPlayerIndex > #playerList then
                    currentPlayerIndex = 1
                end
                updatePlayerDisplay()
            end
        end)
    end

    -- Функция для выполнения Antihit Friend
    local function executeAntihitFriend()
        if #playerList == 0 then
            warn('Нет игроков для выбора!')
            return
        end

        local targetPlayer = playerList[currentPlayerIndex]
        if targetPlayer then
            if antihitButton then
                antihitButton.Text = 'Checking range...'
            end

            if not isPlayerInRange(targetPlayer, 20) then
                if antihitButton then
                    antihitButton.Text = 'Too far!'
                    wait(1)
                    antihitButton.Text = 'Antihit Friend (C)'
                end
                warn('Целевой игрок слишком далеко!')
                return
            end

            if antihitButton then
                antihitButton.Text = 'Shooting...'
            end

            if antihitFriend(targetPlayer) then
                if antihitButton then
                    antihitButton.Text = 'Success!'
                    wait(1)
                    antihitButton.Text = 'Antihit Friend (C)'
                end
            else
                if antihitButton then
                    antihitButton.Text = 'Failed!'
                    wait(1)
                    antihitButton.Text = 'Antihit Friend (C)'
                end
            end
        end
    end

    -- Обработчик кнопки Antihit Friend
    if antihitButton then
        antihitButton.MouseButton1Click:Connect(function()
            executeAntihitFriend()
        end)

        antihitButton.TouchTap:Connect(function()
            executeAntihitFriend()
        end)
    end

    -- Обработчик основной кнопки Control Player
    if controlButton then
        controlButton.MouseButton1Click:Connect(function()
            controlPlayer()
        end)

        controlButton.TouchTap:Connect(function()
            controlPlayer()
        end)
    end

    -- ========== ОБРАБОТЧИК КЛАВИШ ==========
    WebControlConnections.InputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then
            return
        end

        -- Обработка клавиши F для Control Player
        if input.KeyCode == Enum.KeyCode.F then
            controlPlayer()
        end

        -- Обработка клавиши C для Antihit Friend
        if input.KeyCode == Enum.KeyCode.C then
            executeAntihitFriend()
        end
    end)

    -- Очистка при выходе
    WebControlConnections.CharacterRemoving = player.CharacterRemoving:Connect(function()
        if isControlling then
            cancelControl()
        else
            restoreTools()
        end
    end)

    WebControlConnections.GUIDestroying = screenGui.Destroying:Connect(function()
        if isControlling then
            cancelControl()
        else
            restoreTools()
        end
    end)

    WebControlGUI = screenGui
end

local function DisableWebControl()
    if WebControlGUI then
        WebControlGUI:Destroy()
        WebControlGUI = nil
    end
    
    for _, connection in pairs(WebControlConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    WebControlConnections = {}
end

-- Invisibility Steal Function
local InvisibilityStealEnabled = false
local InvisibilityStealGUI = nil
local InvisibilityStealConnections = {}

local function EnableInvisibilitySteal()
    local Players = game:GetService('Players')
    local PhysicsService = game:GetService('PhysicsService')
    local RunService = game:GetService('RunService')
    local UserInputService = game:GetService('UserInputService')
    local TweenService = game:GetService('TweenService')
    local HttpService = game:GetService('HttpService')
    local LocalPlayer = Players.LocalPlayer

    local Backpack = LocalPlayer:WaitForChild('Backpack')
    local PlayerGui = LocalPlayer:WaitForChild('PlayerGui')

    -- Динамические переменные для персонажа
    local Character = nil
    local Humanoid = nil
    local HumanoidRootPart = nil

    -- Настройки
    local IS_ACTIVE = false
    local BASE_Y_OFFSET = -50
    local CAMERA_SENSITIVITY = 0.8
    local TOUCH_SENSITIVITY = 1.0
    local PINCH_SENSITIVITY = 0.01
    local originalPosition = Vector3.new(0, 0, 0)
    local CAMERA_HOLD_TIME = 0.35

    -- Константы для UI
    local PANEL_WIDTH = 200
    local PANEL_HEIGHT = 80
    local CORNER_RADIUS = 8
    local BTN_WIDTH = 180
    local BTN_HEIGHT = 25
    local BTN_RADIUS = 4
    local BTN_FONT_SIZE = 11

    -- Переменные для сохранения позиции
    local savedPosition = nil
    local positionKey = 'InvisibilityStealPosition_' .. LocalPlayer.UserId

    -- Переменные для клона и камеры
    local clonePart = nil
    local cameraController = nil
    local originalCameraType = nil
    local originalCameraSubject = nil
    local lastPlayerPosition = Vector3.new(0, 0, 0)
    local cameraAngle = Vector2.new(0, 0)
    local cameraDistance = 8
    local isDragging = false
    local currentTouchId = nil

    -- Мобильные переменные
    local IS_MOBILE = UserInputService.TouchEnabled
    local touchStartPositions = {}
    local initialPinchDistance = nil
    local isPinching = false

    -- Флаги для отслеживания подключенных событий
    local inputBeganConnection = nil
    local inputEndedConnection = nil
    local inputChangedConnection = nil
    local touchStartedConnection = nil
    local touchMovedConnection = nil
    local touchEndedConnection = nil
    local godModeHealthConnection = nil
    local godModeDiedConnection = nil
    local humanoidDiedConnection = nil
    local heartbeatConnection = nil
    local characterAddedConnection = nil
    local keyBindConnection = nil

    -- Переменные для блокировки быстрых кликов
    local isProcessing = false
    local PROCESSING_DELAY = 0.5

    -- Переменные для прыжка (уникальная функциональность нижнего скрипта)
    local isJumping = false
    local jumpStartTime = 0
    local JUMP_DURATION = 0.3
    local TELEPORT_AT_JUMP_HEIGHT = 0.6

    -- Переменные для UI
    local screenGui = nil
    local mainFrame = nil
    local mainBtn = nil
    local title = nil

    -- Настройки бинда
    local BIND_KEY = Enum.KeyCode.F
    local BIND_ENABLED = true

    -- Функция для получения текущего персонажа
    local function getCurrentCharacter()
        return LocalPlayer.Character
    end

    -- Функция для получения текущего Humanoid
    local function getCurrentHumanoid()
        local character = getCurrentCharacter()
        if character then
            return character:FindFirstChildOfClass('Humanoid')
        end
        return nil
    end

    -- Функция для получения текущего HumanoidRootPart
    local function getCurrentHumanoidRootPart()
        local character = getCurrentCharacter()
        if character then
            return character:FindFirstChild('HumanoidRootPart')
        end
        return nil
    end

    -- Функция для обновления ссылок на персонажа
    local function updateCharacterReferences()
        Character = getCurrentCharacter()
        Humanoid = getCurrentHumanoid()
        HumanoidRootPart = getCurrentHumanoidRootPart()

        if HumanoidRootPart then
            lastPlayerPosition = HumanoidRootPart.Position
            originalPosition = HumanoidRootPart.Position
        end
    end

    -- Загрузка сохраненной позиции
    local function loadSavedPosition()
        local success, result = pcall(function()
            if readfile and isfile and isfile(positionKey) then
                return readfile(positionKey)
            end
            return nil
        end)

        if success and result then
            local data = HttpService:JSONDecode(result)
            savedPosition =
                UDim2.new(data.X.Scale, data.X.Offset, data.Y.Scale, data.Y.Offset)
            return true
        end
        return false
    end

    -- Сохранение позиции
    local function savePosition(position)
        savedPosition = position
        pcall(function()
            if writefile then
                local data = {
                    X = { Scale = position.X.Scale, Offset = position.X.Offset },
                    Y = { Scale = position.Y.Scale, Offset = position.Y.Offset },
                }
                writefile(positionKey, HttpService:JSONEncode(data))
            end
        end)
    end

    -- Функция для настройки перетаскивания
    local function setupDrag(frame)
        local dragging = false
        local dragInput, dragStart, startPos

        local function update(input)
            local delta = input.Position - dragStart
            local newPosition = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
            frame.Position = newPosition
            savePosition(newPosition)
        end

        frame.InputBegan:Connect(function(input)
            if
                input.UserInputType == Enum.UserInputType.MouseButton1
                or input.UserInputType == Enum.UserInputType.Touch
            then
                dragging = true
                dragStart = input.Position
                startPos = frame.Position

                local connection
                connection = input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                        connection:Disconnect()
                    end
                end)
            end
        end)

        frame.InputChanged:Connect(function(input)
            if
                input.UserInputType == Enum.UserInputType.MouseMovement
                or input.UserInputType == Enum.UserInputType.Touch
            then
                dragInput = input
            end
        end)

        UserInputService.InputChanged:Connect(function(input)
            if input == dragInput and dragging then
                update(input)
            end
        end)
    end

    -- Загрузка чувствительности из настроек игры
    local function loadCameraSensitivityFromSettings()
        local UserSettingsService = game:GetService('UserSettings')
        local GameSettings = nil
        local ok, err = pcall(function()
            GameSettings = UserSettingsService:WaitForChild('GameSettings')
        end)
        if
            ok
            and GameSettings
            and type(GameSettings.MouseSensitivity) == 'number'
        then
            CAMERA_SENSITIVITY = GameSettings.MouseSensitivity
        end

        if GameSettings then
            GameSettings.Changed:Connect(function(prop)
                if prop == 'MouseSensitivity' then
                    local ms = GameSettings.MouseSensitivity
                    if type(ms) == 'number' then
                        CAMERA_SENSITIVITY = ms
                    end
                end
            end)
        end
    end

    -- Функция для полной очистки камеры
    local function cleanupCamera()
        if cameraController then
            cameraController:Disconnect()
            cameraController = nil
        end

        if inputBeganConnection then
            inputBeganConnection:Disconnect()
            inputBeganConnection = nil
        end
        if inputEndedConnection then
            inputEndedConnection:Disconnect()
            inputEndedConnection = nil
        end
        if inputChangedConnection then
            inputChangedConnection:Disconnect()
            inputChangedConnection = nil
        end
        if touchStartedConnection then
            touchStartedConnection:Disconnect()
            touchStartedConnection = nil
        end
        if touchMovedConnection then
            touchMovedConnection:Disconnect()
            touchMovedConnection = nil
        end
        if touchEndedConnection then
            touchEndedConnection:Disconnect()
            touchEndedConnection = nil
        end

        isDragging = false
        currentTouchId = nil
        touchStartPositions = {}
        initialPinchDistance = nil
        isPinching = false
    end

    -- Функция для полной очистки клона
    local function cleanupClone()
        if clonePart then
            clonePart:Destroy()
            clonePart = nil
        end
    end

    -- Функция для создания клона HumanoidRootPart
    local function createClone()
        cleanupClone()

        if not HumanoidRootPart then
            return
        end

        clonePart = Instance.new('Part')
        clonePart.Name = 'InvisibilityClone'
        clonePart.Size = Vector3.new(2, 2, 1)
        clonePart.Shape = Enum.PartType.Block
        clonePart.Color = Color3.fromRGB(190, 140, 220)
        clonePart.Material = Enum.Material.Neon
        clonePart.Transparency = 0.5
        clonePart.CanCollide = false
        clonePart.Anchored = true
        clonePart.CastShadow = false

        clonePart.Position = Vector3.new(
            lastPlayerPosition.X,
            lastPlayerPosition.Y,
            lastPlayerPosition.Z
        )

        clonePart.Parent = workspace
    end

    -- Обработка ввода для ПК
    local function setupDesktopCameraInput()
        inputBeganConnection = UserInputService.InputBegan:Connect(
            function(input, gameProcessed)
                if gameProcessed or not IS_ACTIVE or not clonePart then
                    return
                end

                if input.UserInputType == Enum.UserInputType.MouseButton2 then
                    isDragging = true
                    UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
                end
            end
        )

        inputEndedConnection = UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton2 then
                isDragging = false
                UserInputService.MouseBehavior = Enum.MouseBehavior.Default
            end
        end)

        inputChangedConnection = UserInputService.InputChanged:Connect(
            function(input)
                if not IS_ACTIVE or not clonePart then
                    return
                end

                if
                    input.UserInputType == Enum.UserInputType.MouseMovement
                    and isDragging
                then
                    local delta = input.Delta
                    cameraAngle = cameraAngle
                        + Vector2.new(
                            delta.Y * CAMERA_SENSITIVITY * 0.01,
                            -delta.X * CAMERA_SENSITIVITY * 0.01
                        )
                    cameraAngle = Vector2.new(
                        math.clamp(cameraAngle.X, -math.rad(80), math.rad(80)),
                        cameraAngle.Y
                    )
                end

                if input.UserInputType == Enum.UserInputType.MouseWheel then
                    cameraDistance =
                        math.clamp(cameraDistance - input.Position.Z * 2, 2, 20)
                end
            end
        )
    end

    -- Функция для улучшенного управления камерой на мобильных устройствах
    local function setupEnhancedMobileCamera()
        cleanupCamera()

        local touchStartPos = nil
        local touchStartTime = nil
        local isCameraDragging = false
        local pinchTouches = {}

        touchStartedConnection = UserInputService.TouchStarted:Connect(
            function(touch)
                if not IS_ACTIVE or not clonePart then
                    return
                end

                -- Проверяем, не касается ли UI панель
                local touchPos = touch.Position
                local framePos = mainFrame.AbsolutePosition
                local frameSize = mainFrame.AbsoluteSize

                local isTouchingUI = touchPos.X >= framePos.X
                    and touchPos.X <= framePos.X + frameSize.X
                    and touchPos.Y >= framePos.Y
                    and touchPos.Y <= framePos.Y + frameSize.Y

                if not isTouchingUI then
                    touchStartPos = touch.Position
                    touchStartTime = os.clock()
                    isCameraDragging = true
                    currentTouchId = touch
                end

                -- Обработка масштабирования
                table.insert(pinchTouches, touch)

                if #pinchTouches == 2 then
                    local pos1 = pinchTouches[1].Position
                    local pos2 = pinchTouches[2].Position
                    initialPinchDistance = (pos1 - pos2).Magnitude
                end
            end
        )

        touchEndedConnection = UserInputService.TouchEnded:Connect(function(touch)
            if touch == currentTouchId then
                isCameraDragging = false
                currentTouchId = nil
                touchStartPos = nil
            end

            -- Очистка масштабирования
            for i, t in ipairs(pinchTouches) do
                if t == touch then
                    table.remove(pinchTouches, i)
                    break
                end
            end

            if #pinchTouches < 2 then
                initialPinchDistance = nil
            end
        end)

        touchMovedConnection = UserInputService.TouchMoved:Connect(function(touch)
            if not IS_ACTIVE or not clonePart then
                return
            end

            -- Обработка вращения камеры
            if isCameraDragging and touch == currentTouchId and touchStartPos then
                local currentPos = touch.Position
                local delta = currentPos - touchStartPos

                -- Обновляем углы камеры
                cameraAngle = cameraAngle
                    + Vector2.new(
                        delta.Y * TOUCH_SENSITIVITY * 0.03,
                        -delta.X * TOUCH_SENSITIVITY * 0.03
                    )

                -- Ограничиваем вертикальный угол
                cameraAngle = Vector2.new(
                    math.clamp(cameraAngle.X, -math.rad(75), math.rad(75)),
                    cameraAngle.Y
                )

                touchStartPos = currentPos
            end

            -- Обработка масштабирования
            if #pinchTouches >= 2 then
                local pos1 = pinchTouches[1].Position
                local pos2 = pinchTouches[2].Position
                local currentDistance = (pos1 - pos2).Magnitude

                if initialPinchDistance then
                    local scale = currentDistance / initialPinchDistance
                    cameraDistance = math.clamp(cameraDistance * (2 - scale), 2, 25)
                    initialPinchDistance = currentDistance
                end
            end
        end)
    end

    -- Функция для настройки управления камерой
    local function setupCameraInput()
        cleanupCamera()

        if IS_MOBILE then
            setupEnhancedMobileCamera()
        else
            setupDesktopCameraInput()
        end
    end

    -- Функция для привязки камеры к клону
    local function attachCameraToClone()
        if not clonePart then
            return
        end

        originalCameraType = workspace.CurrentCamera.CameraType
        originalCameraSubject = workspace.CurrentCamera.CameraSubject

        workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
        setupCameraInput()

        cameraController = RunService.RenderStepped:Connect(function()
            if clonePart and clonePart.Parent and IS_ACTIVE then
                -- Обновляем позицию камеры на основе угла и расстояния
                local cameraPos = clonePart.Position
                    + Vector3.new(
                        math.sin(cameraAngle.Y)
                            * math.cos(cameraAngle.X)
                            * cameraDistance,
                        math.sin(cameraAngle.X) * cameraDistance + 2,
                        math.cos(cameraAngle.Y)
                            * math.cos(cameraAngle.X)
                            * cameraDistance
                    )

                workspace.CurrentCamera.CFrame =
                    CFrame.new(cameraPos, clonePart.Position + Vector3.new(0, 2, 0))
            end
        end)
    end

    -- Функция для восстановления оригинальной камеры
    local function restoreOriginalCamera()
        cleanupCamera()

        if workspace.CurrentCamera then
            workspace.CurrentCamera.CameraType = originalCameraType
                or Enum.CameraType.Custom
            if originalCameraSubject and originalCameraSubject.Parent then
                workspace.CurrentCamera.CameraSubject = originalCameraSubject
            else
                local currentHumanoid = getCurrentHumanoid()
                if currentHumanoid then
                    workspace.CurrentCamera.CameraSubject = currentHumanoid
                end
            end
        end

        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    end

    -- Функция для обновления позиции клона
    local function updateClonePosition()
        if not clonePart or not IS_ACTIVE then
            return
        end

        local currentHRP = getCurrentHumanoidRootPart()
        if not currentHRP then
            return
        end

        local currentPos = currentHRP.Position
        lastPlayerPosition = currentPos
        clonePart.Position =
            Vector3.new(currentPos.X, clonePart.Position.Y, currentPos.Z)

        local lookVector = currentHRP.CFrame.LookVector
        lookVector = Vector3.new(lookVector.X, 0, lookVector.Z)
        if lookVector.Magnitude > 0 then
            clonePart.CFrame =
                CFrame.new(clonePart.Position, clonePart.Position + lookVector)
        end
    end

    -- Функция для остановки фиксации позиции
    local function cleanupPositionFix()
        if heartbeatConnection then
            heartbeatConnection:Disconnect()
            heartbeatConnection = nil
        end
    end

    -- Функция для запуска фиксации позиции
    local function setupPositionFix()
        cleanupPositionFix()

        heartbeatConnection = RunService.Heartbeat:Connect(function()
            if IS_ACTIVE then
                local currentHRP = getCurrentHumanoidRootPart()
                if currentHRP then
                    currentHRP.CFrame = CFrame.new(originalPosition)
                    currentHRP.Velocity = Vector3.new(0, 0, 0)
                    currentHRP.RotVelocity = Vector3.new(0, 0, 0)
                    updateClonePosition()
                end
            end
        end)
    end

    -- Функция для получения позиции телепортации
    local function getTeleportPosition(currentPosition)
        local additionalOffset = 0
        if currentPosition.Y > 0 then
            additionalOffset = -currentPosition.Y
        end
        local totalYOffset = BASE_Y_OFFSET + additionalOffset
        local x = currentPosition.X
        local z = currentPosition.Z
        local y = currentPosition.Y + totalYOffset
        return Vector3.new(x, y, z)
    end

    -- Функция для выполнения прыжка (уникальная функциональность)
    local function performJump()
        if not Humanoid then
            return false
        end

        isJumping = true
        jumpStartTime = os.clock()

        -- Заставляем персонажа прыгнуть
        Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        return true
    end

    -- Функция для телепортации
    local function teleportToPosition()
        local currentHRP = getCurrentHumanoidRootPart()
        if not currentHRP then
            return
        end

        lastPlayerPosition = currentHRP.Position
        local currentPosition = currentHRP.Position
        local teleportPosition = getTeleportPosition(currentPosition)

        local success, err = pcall(function()
            currentHRP.CFrame = CFrame.new(teleportPosition)
            currentHRP.Velocity = Vector3.new(0, 0, 0)
            currentHRP.RotVelocity = Vector3.new(0, 0, 0)
            originalPosition = teleportPosition
        end)
    end

    -- Функция для возврата персонажа
    local function returnPlayerUp()
        local currentHRP = getCurrentHumanoidRootPart()
        if not currentHRP then
            return
        end

        local currentPosition = currentHRP.Position
        local returnPosition =
            Vector3.new(currentPosition.X, currentPosition.Y + 2, currentPosition.Z)

        local success, err = pcall(function()
            currentHRP.CFrame = CFrame.new(returnPosition)
            currentHRP.Velocity = Vector3.new(0, 0, 0)
            currentHRP.RotVelocity = Vector3.new(0, 0, 0)
        end)
    end

    -- Функция для активации God Mode
    local function enableGodMode()
        local currentHumanoid = getCurrentHumanoid()
        if not currentHumanoid then
            return
        end

        if godModeHealthConnection then
            godModeHealthConnection:Disconnect()
            godModeHealthConnection = nil
        end
        if godModeDiedConnection then
            godModeDiedConnection:Disconnect()
            godModeDiedConnection = nil
        end

        currentHumanoid.MaxHealth = math.huge
        currentHumanoid.Health = math.huge

        godModeHealthConnection = currentHumanoid
            :GetPropertyChangedSignal('Health')
            :Connect(function()
                if IS_ACTIVE then
                    currentHumanoid.Health = math.huge
                end
            end)

        godModeDiedConnection = currentHumanoid.Died:Connect(function()
            if IS_ACTIVE then
                local newHumanoid = getCurrentHumanoid()
                if newHumanoid then
                    newHumanoid.Health = math.huge
                end
            end
        end)
    end

    -- Функция для деактивации God Mode
    local function disableGodMode()
        if godModeHealthConnection then
            godModeHealthConnection:Disconnect()
            godModeHealthConnection = nil
        end
        if godModeDiedConnection then
            godModeDiedConnection:Disconnect()
            godModeDiedConnection = nil
        end

        local currentHumanoid = getCurrentHumanoid()
        if currentHumanoid then
            currentHumanoid.MaxHealth = 100
            currentHumanoid.Health = 100
        end
    end

    -- Функция для обработки смерти персонажа
    local function onHumanoidDied()
        if IS_ACTIVE then
            IS_ACTIVE = false
            isJumping = false

            cleanupCamera()
            cleanupClone()
            cleanupPositionFix()
            disableGodMode()
            restoreOriginalCamera()

            if mainBtn then
                mainBtn.Text = 'OFF'
                mainBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            end
        end
    end

    -- Функция для отслеживания смерти персонажа
    local function setupDeathTracking()
        if humanoidDiedConnection then
            humanoidDiedConnection:Disconnect()
            humanoidDiedConnection = nil
        end

        local currentHumanoid = getCurrentHumanoid()
        if currentHumanoid then
            humanoidDiedConnection = currentHumanoid.Died:Connect(onHumanoidDied)
        end
    end

    -- Основная функция для переключения состояния (с прыжком)
    local function setActive(state)
        if isProcessing then
            return
        end
        isProcessing = true

        updateCharacterReferences()

        if state then
            -- Включение: сначала прыжок, потом телепортация и активация
            if performJump() then
                -- Ждем немного перед телепортацией (в середине прыжка)
                task.delay(JUMP_DURATION * TELEPORT_AT_JUMP_HEIGHT, function()
                    if not isJumping then
                        return
                    end

                    local currentHRP = getCurrentHumanoidRootPart()
                    if currentHRP then
                        cleanupCamera()
                        cleanupClone()
                        cleanupPositionFix()

                        teleportToPosition()
                        createClone()
                        attachCameraToClone()
                        enableGodMode()
                        setupDeathTracking()
                        setupPositionFix()

                        IS_ACTIVE = true

                        if mainBtn then
                            mainBtn.Text = 'ON'
                            mainBtn.BackgroundColor3 = Color3.fromRGB(0, 100, 0)
                        end
                    else
                        IS_ACTIVE = false
                    end

                    isJumping = false
                    isProcessing = false
                end)

                -- Таймаут на случай, если прыжок не сработал
                task.delay(JUMP_DURATION + 0.5, function()
                    isJumping = false
                    if not IS_ACTIVE then
                        isProcessing = false
                    end
                end)
            else
                isProcessing = false
            end
        else
            -- Выключение: просто возвращаем персонажа
            IS_ACTIVE = false
            isJumping = false

            returnPlayerUp()
            disableGodMode()
            cleanupPositionFix()

            task.delay(CAMERA_HOLD_TIME, function()
                if not IS_ACTIVE then
                    restoreOriginalCamera()
                    cleanupClone()
                    cleanupCamera()
                end
            end)

            if mainBtn then
                mainBtn.Text = 'OFF'
                mainBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            end

            task.delay(PROCESSING_DELAY, function()
                isProcessing = false
            end)
        end
    end

    -- Функция для переключения состояния по бинду
    local function toggleByBind()
        if not isProcessing then
            setActive(not IS_ACTIVE)
            if mainBtn then
                mainBtn.Text = IS_ACTIVE and 'ON' or 'OFF'
                mainBtn.BackgroundColor3 = IS_ACTIVE and Color3.fromRGB(0, 100, 0) or Color3.fromRGB(45, 45, 45)
            end
        end
    end

    -- Настройка бинда клавиши
    local function setupKeyBind()
        if keyBindConnection then
            keyBindConnection:Disconnect()
            keyBindConnection = nil
        end

        keyBindConnection = UserInputService.InputBegan:Connect(
            function(input, gameProcessed)
                if gameProcessed then
                    return
                end

                if input.KeyCode == BIND_KEY and BIND_ENABLED then
                    toggleByBind()
                end
            end
        )
    end

    -- Создание UI в стиле нижнего скрипта
    local function createUI()
        if screenGui then
            screenGui:Destroy()
        end

        screenGui = Instance.new('ScreenGui')
        screenGui.Name = 'InvisibilityStealPro'
        screenGui.ResetOnSpawn = false
        screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        screenGui.Parent = PlayerGui

        -- Основной контейнер
        mainFrame = Instance.new('Frame')
        mainFrame.Size = UDim2.new(0, PANEL_WIDTH, 0, PANEL_HEIGHT)

        if savedPosition then
            mainFrame.Position = savedPosition
        else
            mainFrame.Position = UDim2.new(0, 10, 0, 10)
        end

        mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        mainFrame.BackgroundTransparency = 0.1
        mainFrame.BorderSizePixel = 0
        mainFrame.Active = true

        local UICorner = Instance.new('UICorner')
        UICorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
        UICorner.Parent = mainFrame

        -- Заголовок
        title = Instance.new('TextLabel')
        title.Text = 'Invisibility (' .. BIND_KEY.Name .. ')'
        title.Size = UDim2.new(1, 0, 0, 20)
        title.Position = UDim2.new(0, 0, 0, 0)
        title.BackgroundTransparency = 1
        title.TextColor3 = Color3.fromRGB(200, 200, 200)
        title.Font = Enum.Font.GothamMedium
        title.TextSize = 12
        title.TextXAlignment = Enum.TextXAlignment.Center

        -- Кнопка управления
        mainBtn = Instance.new('TextButton')
        mainBtn.Size = UDim2.new(0.9, 0, 0, BTN_HEIGHT)
        mainBtn.Position = UDim2.new(0.05, 0, 0.3, 0)
        mainBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        mainBtn.Text = 'OFF'
        mainBtn.TextColor3 = Color3.fromRGB(220, 220, 220)
        mainBtn.Font = Enum.Font.Gotham
        mainBtn.TextSize = 11
        mainBtn.AutoButtonColor = false

        local ButtonCorner = Instance.new('UICorner')
        ButtonCorner.CornerRadius = UDim.new(0, BTN_RADIUS)
        ButtonCorner.Parent = mainBtn

        -- Иерархия объектов
        title.Parent = mainFrame
        mainBtn.Parent = mainFrame
        mainFrame.Parent = screenGui

        -- Настройка перетаскивания
        setupDrag(mainFrame)

        -- Обработчики событий
        mainBtn.MouseButton1Click:Connect(function()
            if not isProcessing then
                setActive(not IS_ACTIVE)
                mainBtn.Text = IS_ACTIVE and 'ON' or 'OFF'
                mainBtn.BackgroundColor3 = IS_ACTIVE and Color3.fromRGB(0, 100, 0) or Color3.fromRGB(45, 45, 45)
            end
        end)

        -- Поддержка Touch для мобильных устройств
        mainBtn.TouchTap:Connect(function()
            if not isProcessing then
                setActive(not IS_ACTIVE)
                mainBtn.Text = IS_ACTIVE and 'ON' or 'OFF'
                mainBtn.BackgroundColor3 = IS_ACTIVE and Color3.fromRGB(0, 100, 0) or Color3.fromRGB(45, 45, 45)
            end
        end)
    end

    -- Обработчик респауна
    local function onCharacterAdded(newCharacter)
        updateCharacterReferences()
        setupDeathTracking()

        if IS_ACTIVE then
            IS_ACTIVE = false
            isJumping = false
            cleanupCamera()
            cleanupClone()
            cleanupPositionFix()
            disableGodMode()
            restoreOriginalCamera()

            if mainBtn then
                mainBtn.Text = 'OFF'
                mainBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            end
        end
    end

    -- Инициализация при запуске
    local function initialize()
        updateCharacterReferences()
        setupDeathTracking()
        setupKeyBind()
        createUI() -- Добавляем создание UI
        
        characterAddedConnection =
            LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    end

    initialize()

    -- Сохраняем соединения
    InvisibilityStealConnections.CharacterAdded = characterAddedConnection
    InvisibilityStealConnections.KeyBind = keyBindConnection
    InvisibilityStealGUI = screenGui
end

local function DisableInvisibilitySteal()
    if InvisibilityStealGUI then
        InvisibilityStealGUI:Destroy()
        InvisibilityStealGUI = nil
    end
    
    for _, connection in pairs(InvisibilityStealConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    InvisibilityStealConnections = {}
end

-- Float Module
local FloatModule = {}
local FloatEnabled = false
local FloatGUI = nil
local FloatConnections = {}

local function EnableFloat()
    local Player = game:GetService('Players').LocalPlayer
    local UIS = game:GetService('UserInputService')
    local RunService = game:GetService('RunService')
    local CoreGui = game:GetService('CoreGui')

    -- Settings
    local FLY_SPEED = 30
    local FALL_SPEED = 0.1
    local WALK_SPEED = 16
    local MAX_HEIGHT_GAIN = 21.8
    local isFlying = false
    local heightLimitEnabled = true  -- По умолчанию включено
    local currentHeightGain = 0
    local scriptActive = true
    local flightEnabled = false  -- По умолчанию выключено

    -- Create interface
    local screenGui = Instance.new('ScreenGui')
    screenGui.Name = 'FloatUI'
    screenGui.Parent = CoreGui

    local frame = Instance.new('Frame')
    frame.Size = UDim2.new(0, 200, 0, 100)
    -- Позиция слева экрана с отступом 10 пикселей от края
    frame.Position = UDim2.new(0, 10, 0.2, 0)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BackgroundTransparency = 0.3
    frame.BorderSizePixel = 0
    frame.Active = true
    frame.Draggable = false

    local uiCorner = Instance.new('UICorner')
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = frame

    -- Flight toggle
    local flightToggle = Instance.new('TextButton')
    flightToggle.Size = UDim2.new(0, 80, 0, 30)
    flightToggle.Position = UDim2.new(0.1, 0, 0.1, 0)
    flightToggle.BackgroundColor3 = Color3.fromRGB(150, 0, 0)  -- Красный, так как выключено по умолчанию
    flightToggle.Text = 'Flight: OFF'  -- Текст OFF по умолчанию
    flightToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
    flightToggle.Font = Enum.Font.GothamBold
    flightToggle.TextSize = 12

    -- Height limit toggle
    local toggle = Instance.new('TextButton')
    toggle.Size = UDim2.new(0, 80, 0, 30)
    toggle.Position = UDim2.new(0.1, 0, 0.5, 0)
    toggle.BackgroundColor3 = Color3.fromRGB(0, 150, 0)  -- Зеленый цвет, так как включено по умолчанию
    toggle.Text = 'Limit: ON'  -- Текст ON по умолчанию
    toggle.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggle.Font = Enum.Font.GothamBold
    toggle.TextSize = 12

    -- Bind info label
    local bindLabel = Instance.new('TextLabel')
    bindLabel.Size = UDim2.new(0, 160, 0, 20)
    bindLabel.Position = UDim2.new(0.1, 0, 0.8, 0)
    bindLabel.BackgroundTransparency = 1
    bindLabel.Text = 'Bind: C (Toggle Flight)'
    bindLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    bindLabel.Font = Enum.Font.Gotham
    bindLabel.TextSize = 10
    bindLabel.TextXAlignment = Enum.TextXAlignment.Left

    frame.Parent = screenGui
    flightToggle.Parent = frame
    toggle.Parent = frame
    bindLabel.Parent = frame
    uiCorner.Parent = frame

    -- Функция для адаптивного размера интерфейса
    local function updateUISize()
        local viewportSize = workspace.CurrentCamera.ViewportSize
        local scaleFactor = math.min(viewportSize.X / 1920, viewportSize.Y / 1080) * 0.8
        
        -- Базовые размеры
        local baseWidth = 200
        local baseHeight = 100
        local baseTextSize = 12
        
        -- Адаптивные размеры
        local adaptiveWidth = math.max(baseWidth * scaleFactor, 200)  -- Минимальная ширина 150
        local adaptiveHeight = math.max(baseHeight * scaleFactor, 120)  -- Минимальная высота 80
        local adaptiveTextSize = math.max(baseTextSize * scaleFactor, 14)  -- Минимальный размер текста 10
        
        -- Применяем размеры к фрейму
        frame.Size = UDim2.new(0, adaptiveWidth, 0, adaptiveHeight)
        
        -- Применяем размеры к кнопкам
        local buttonWidth = adaptiveWidth * 0.40  -- 40% от ширины фрейма
        local buttonHeight = adaptiveHeight * 0.30  -- 30% от высоты фрейма
        
        flightToggle.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
        toggle.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
        
        -- Позиционируем кнопки
        flightToggle.Position = UDim2.new(0.1, 0, 0.1, 0)
        toggle.Position = UDim2.new(0.1, 0, 0.5, 0)
        bindLabel.Position = UDim2.new(0.1, 0, 0.8, 0)
        
        -- Обновляем размер текста
        flightToggle.TextSize = adaptiveTextSize
        toggle.TextSize = adaptiveTextSize
        bindLabel.TextSize = adaptiveTextSize - 2
    end

    -- Вызываем при создании и при изменении размера экрана
    updateUISize()
    workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(updateUISize)

    -- ========== ФУНКЦИЯ ПЕРЕТАСКИВАНИЯ ==========
    local function setupDrag(frame)
        local dragging = false
        local dragStart, startPos

        local function onInputBegan(input)
            if
                input.UserInputType == Enum.UserInputType.MouseButton1
                or input.UserInputType == Enum.UserInputType.Touch
            then
                dragging = true
                dragStart = input.Position
                startPos = frame.Position
            end
        end

        local function onInputChanged(input)
            if
                dragging
                and (
                    input.UserInputType == Enum.UserInputType.MouseMovement
                    or input.UserInputType == Enum.UserInputType.Touch
                )
            then
                local delta = input.Position - dragStart
                frame.Position = UDim2.new(
                    startPos.X.Scale,
                    startPos.X.Offset + delta.X,
                    startPos.Y.Scale,
                    startPos.Y.Offset + delta.Y
                )
            end
        end

        local function onInputEnded(input)
            if
                input.UserInputType == Enum.UserInputType.MouseButton1
                or input.UserInputType == Enum.UserInputType.Touch
            then
                dragging = false
            end
        end

        frame.InputBegan:Connect(onInputBegan)
        frame.InputChanged:Connect(onInputChanged)
        UIS.InputChanged:Connect(onInputChanged)
        UIS.InputEnded:Connect(onInputEnded)
    end

    setupDrag(frame)

    -- Reset velocity function
    local function resetVelocity()
        if
            Player.Character
            and Player.Character:FindFirstChild('HumanoidRootPart')
        then
            Player.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        end
    end

    -- Set walk speed function
    local function setWalkSpeed()
        if Player.Character and Player.Character:FindFirstChild('Humanoid') then
            Player.Character.Humanoid.WalkSpeed = WALK_SPEED
        end
    end

    -- Функция переключения полета
    local function toggleFlight()
        flightEnabled = not flightEnabled
        if flightEnabled then
            flightToggle.Text = 'Flight: ON'
            flightToggle.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
            setWalkSpeed()
            print("Flight: ENABLED")
        else
            flightToggle.Text = 'Flight: OFF'
            flightToggle.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
            resetVelocity()
            isFlying = false
            print("Flight: DISABLED")
        end
    end

    -- Flight toggle handler
    flightToggle.MouseButton1Click:Connect(toggleFlight)

    -- Height limit toggle handler
    toggle.MouseButton1Click:Connect(function()
        heightLimitEnabled = not heightLimitEnabled
        if heightLimitEnabled then
            toggle.Text = 'Limit: ON'
            toggle.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
        else
            toggle.Text = 'Limit: OFF'
            toggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        end
    end)

    -- ========== БИНД НА КЛАВИШУ C ==========
    local inputBeganConnection = UIS.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end -- Игнорируем если игра обрабатывает ввод
        
        -- Бинд на C для переключения полета
        if input.KeyCode == Enum.KeyCode.C then
            toggleFlight()
        end
        
        -- Управление полетом пробелом (работает только когда полет включен)
        if input.KeyCode == Enum.KeyCode.Space and flightEnabled then
            isFlying = true
        end
    end)

    -- Space release handler
    local inputEndedConnection = UIS.InputEnded:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.Space and flightEnabled then
            isFlying = false
        end
    end)

    -- Main flight function
    local function fly()
        if not scriptActive or not flightEnabled then
            return
        end

        if not Player.Character then
            return
        end

        local root = Player.Character:FindFirstChild('HumanoidRootPart')
        if not root then
            return
        end

        if isFlying then
            if heightLimitEnabled then
                if currentHeightGain < MAX_HEIGHT_GAIN then
                    local remainingGain = MAX_HEIGHT_GAIN - currentHeightGain
                    local actualSpeed = math.min(FLY_SPEED, remainingGain * 10)
                    root.Velocity =
                        Vector3.new(root.Velocity.X, actualSpeed, root.Velocity.Z)
                    currentHeightGain = currentHeightGain
                        + (actualSpeed * RunService.Heartbeat:Wait())
                else
                    root.Velocity = Vector3.new(root.Velocity.X, 0, root.Velocity.Z)
                end
            else
                root.Velocity =
                    Vector3.new(root.Velocity.X, FLY_SPEED, root.Velocity.Z)
            end
        else
            root.Velocity =
                Vector3.new(root.Velocity.X, -FALL_SPEED, root.Velocity.Z)
            currentHeightGain = 0
        end
    end

    -- Main loop
    local heartbeatConnection = RunService.Heartbeat:Connect(function()
        if flightEnabled then
            fly()
        end
    end)

    -- Set initial walk speed (но полет выключен)
    setWalkSpeed()

    -- Сохраняем соединения
    FloatConnections.InputBegan = inputBeganConnection
    FloatConnections.InputEnded = inputEndedConnection
    FloatConnections.Heartbeat = heartbeatConnection
    FloatGUI = screenGui

    print("Float Module loaded! Bind: C (Toggle Flight) - Flight is OFF by default")
end

local function DisableFloat()
    if FloatGUI then
        FloatGUI:Destroy()
        FloatGUI = nil
    end
    
    for _, connection in pairs(FloatConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    FloatConnections = {}
end

-- Xray Function
local XrayEnabled = false
local XrayConnections = {}
local XrayOriginalTransparency = {}

local function EnableXray()
    local Workspace = game:GetService('Workspace')
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer

    local ALWAYS_TRANSPARENT_OBJECTS = {
        "AnimalTarget",
        "DeliveryHitbox", 
        "MainRoot",
        "Multiplier",
        "PlotSign",
        "Slope",
        "Spawn",
        "StealHitbox"
    }

    local ALLOWED_OBJECTS = {
        "AnimalPodiums",
        "Decorations", 
        "InvisibleWalls",
        "Laser",
        "LaserHitbox",
        "Purchases",
        "Unlock",
        "FriendPanel",
        "Model",
        "AnimalTarget",
        "DeliveryHitbox", 
        "MainRoot",
        "Multiplier",
        "PlotSign",
        "Slope",
        "Spawn",
        "StealHitbox"
    }

    local function IsObjectAllowed(objectName)
        for _, allowedName in ipairs(ALLOWED_OBJECTS) do
            if objectName == allowedName then
                return true
            end
        end
        return false
    end

    local function SetPlotTransparency(plot)
        if not plot then
            return
        end
        
        local function processDescendants(parent)
            for _, descendant in ipairs(parent:GetDescendants()) do
                if descendant ~= plot and descendant:IsA("BasePart") then
                    
                    local isAllowedObject = IsObjectAllowed(descendant.Name)
                    
                    if not isAllowedObject then
                        local currentParent = descendant.Parent
                        local hasAllowedParent = false
                        
                        while currentParent and currentParent ~= plot do
                            if IsObjectAllowed(currentParent.Name) then
                                hasAllowedParent = true
                                break
                            end
                            currentParent = currentParent.Parent
                        end
                        
                        if not hasAllowedParent then
                            continue
                        end
                    end
                    
                    local isSpecialObject = false
                    local isAnimalPodium = false
                    local isPurchases = false
                    local isDecorationWithoutStructure = false
                    
                    if descendant.Name == "PlotSign" then
                        isSpecialObject = true
                    else
                        for _, objectName in ipairs(ALWAYS_TRANSPARENT_OBJECTS) do
                            if descendant.Name == objectName then
                                isSpecialObject = true
                                break
                            end
                        end
                    end
                    
                    local current = descendant
                    while current and current ~= plot do
                        if current.Name == "AnimalPodiums" then
                            isAnimalPodium = true
                            break
                        elseif current.Name == "Purchases" then
                            isPurchases = true
                            break
                        end
                        current = current.Parent
                    end
                    
                    local decorationModel = descendant:FindFirstAncestorOfClass("Model")
                    if decorationModel then
                        local currentCheck = decorationModel
                        local isInDecorations = false
                        
                        while currentCheck and currentCheck ~= plot do
                            if currentCheck.Name == "Decorations" then
                                isInDecorations = true
                                break
                            end
                            currentCheck = currentCheck.Parent
                        end
                        
                        if isInDecorations then
                            local hasStructureBaseHome = false
                            local structureBaseHome = decorationModel:FindFirstChild("structure base home")
                            if not structureBaseHome then
                                structureBaseHome = decorationModel:FindFirstChild("structure base home", true)
                            end
                            
                            if structureBaseHome then
                                hasStructureBaseHome = true
                            end
                            
                            if not hasStructureBaseHome then
                                isDecorationWithoutStructure = true
                            end
                        end
                    end
                    
                    if not XrayOriginalTransparency[descendant] then
                        XrayOriginalTransparency[descendant] = descendant.Transparency
                    end
                    
                    if descendant.Name == "PlotSign" then
                        descendant.Transparency = 1
                    elseif isSpecialObject or isAnimalPodium or isPurchases or isDecorationWithoutStructure then
                        descendant.Transparency = 1
                    else
                        descendant.Transparency = 0.7
                    end
                end
            end
        end
        
        processDescendants(plot)
    end

    local function RestorePlotTransparency(plot)
        if not plot then
            return
        end
        
        for object, originalTransparency in pairs(XrayOriginalTransparency) do
            if object and object.Parent and object:IsDescendantOf(plot) then
                object.Transparency = originalTransparency
            end
        end
    end

    local function SetupPlotTransparency(plot)
        if not plot then
            return
        end

        SetPlotTransparency(plot)
    end

    -- Initialize existing plots
    local Plots = Workspace:FindFirstChild('Plots')
    if Plots then
        for _, plot in pairs(Plots:GetChildren()) do
            task.spawn(function()
                SetupPlotTransparency(plot)
            end)
        end

        XrayConnections.Plots = Plots.ChildAdded:Connect(function(plot)
            task.wait(1)
            SetupPlotTransparency(plot)
        end)
        
        XrayConnections.PlotsRemoved = Plots.ChildRemoved:Connect(function(plot)
            RestorePlotTransparency(plot)
        end)
    end
end

local function DisableXray()
    for object, originalTransparency in pairs(XrayOriginalTransparency) do
        if object and object.Parent then
            object.Transparency = originalTransparency
        end
    end
    
    XrayOriginalTransparency = {}
    
    for _, connection in pairs(XrayConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    XrayConnections = {}
end

-- Main Tab
local Tab = Window:Tab({Title = "Main", Icon = "star"}) do
    -- Speed Boost Section
    Tab:Section({Title = "Speed Boost"})

    Tab:Toggle({
        Title = "Enable Speed Boost",
        Desc = "Toggle to enable or disable speed boost",
        Value = false,
        Callback = function(v)
            SpeedBoostModule:SetEnabled(v)
        end
    })

    Tab:Slider({
        Title = "Speed Value",
        Min = 1,
        Max = 45,
        Rounding = 0,
        Value = 16,
        Callback = function(val)
            SpeedBoostModule:SetSpeed(val)
        end
    })

    -- Visuals Section
    Tab:Section({Title = "Visuals"})
    
    Tab:Toggle({
        Title = "Anti-Effects",
        Desc = "Remove visual effects and fix camera FOV",
        Value = false,
        Callback = function(v)
            AntiEffectsEnabled = v
            if v then
                EnableAntiEffects()
            else
                DisableAntiEffects()
            end
            Window:Notify({
                Title = "Anti-Effects",
                Desc = v and "Anti-effects enabled!" or "Anti-effects disabled!",
                Time = 3
            })
        end
    })

    Tab:Toggle({
        Title = "Wallhack",
        Desc = "Highlight other players through walls",
        Value = false,
        Callback = function(v)
            WallhackEnabled = v
            if v then
                EnableWallhack()
            else
                DisableWallhack()
            end
            Window:Notify({
                Title = "Wallhack",
                Desc = v and "Wallhack enabled!" or "Wallhack disabled!",
                Time = 3
            })
        end
    })

    Tab:Toggle({
        Title = "Timer ESP",
        Desc = "Show plot unlock timers",
        Value = false,
        Callback = function(v)
            TimerESPEnabled = v
            if v then
                EnableTimerESP()
            else
                DisableTimerESP()
            end
            Window:Notify({
                Title = "Timer ESP",
                Desc = v and "Timer ESP enabled!" or "Timer ESP disabled!",
                Time = 3
            })
        end
    })

    Tab:Toggle({
        Title = "Nametags ESP",
        Desc = "Show player nametags",
        Value = false,
        Callback = function(v)
            NametagsEnabled = v
            if v then
                EnableNametags()
            else
                DisableNametags()
            end
            Window:Notify({
                Title = "Nametags ESP",
                Desc = v and "Nametags enabled!" or "Nametags disabled!",
                Time = 3
            })
        end
    })

    Tab:Toggle({
        Title = "Brainrot ESP",
        Desc = "Show best pet information",
        Value = false,
        Callback = function(v)
            BrainrotESPEnabled = v
            if v then
                EnableBrainrotESP()
            else
                DisableBrainrotESP()
            end
            Window:Notify({
                Title = "Brainrot ESP",
                Desc = v and "Brainrot ESP enabled!" or "Brainrot ESP disabled!",
                Time = 3
            })
        end
    })

    Tab:Toggle({
        Title = "Xray",
        Desc = "Make plots transparent",
        Value = false,
        Callback = function(v)
            XrayEnabled = v
            if v then
                EnableXray()
            else
                DisableXray()
            end
            Window:Notify({
                Title = "Xray",
                Desc = v and "Xray enabled!" or "Xray disabled!",
                Time = 3
            })
        end
    })

    -- Web Control Section
    Tab:Section({Title = "Web Control"})
    
    Tab:Toggle({
        Title = "Web Control",
        Desc = "Control players with web slinger (F to control, C to antihit)",
        Value = false,
        Callback = function(v)
            WebControlEnabled = v
            if v then
                EnableWebControl()
            else
                DisableWebControl()
            end
            Window:Notify({
                Title = "Web Control",
                Desc = v and "Web Control enabled! Use F and C keys" or "Web Control disabled!",
                Time = 3
            })
        end
    })

    -- Invisibility Steal Section
    Tab:Section({Title = "Invisibility Steal"})
    
    Tab:Toggle({
        Title = "Invisibility Steal",
        Desc = "Become invisible and control camera separately",
        Value = false,
        Callback = function(v)
            InvisibilityStealEnabled = v
            if v then
                EnableInvisibilitySteal()
            else
                DisableInvisibilitySteal()
            end
            Window:Notify({
                Title = "Invisibility Steal",
                Desc = v and "Invisibility Steal enabled!" or "Invisibility Steal disabled!",
                Time = 3
            })
        end
    })

    -- Float Section
    Tab:Section({Title = "Float"})
    
    Tab:Toggle({
        Title = "Float",
        Desc = "Flight module with height limit (C to toggle flight)",
        Value = false,
        Callback = function(v)
            FloatEnabled = v
            if v then
                EnableFloat()
            else
                DisableFloat()
            end
            Window:Notify({
                Title = "Float",
                Desc = v and "Float enabled! Use C to toggle flight" or "Float disabled!",
                Time = 3
            })
        end
    })
end

-- Final Notification
Window:Notify({
    Title = "Snow Hub Loaded",
    Desc = "All modules have been successfully loaded!",
    Time = 4
})
