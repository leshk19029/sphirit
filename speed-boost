-- Ожидаем загрузки игры
if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- Ожидаем появления LocalPlayer
local Players = game:GetService('Players')
local player = Players.LocalPlayer
while not player do
    Players.PlayerAdded:Wait()
    player = Players.LocalPlayer
end

-- Функция для генерации HWID
local function generateHWID()
    local hwid = ''
    local success, result = pcall(function()
        return game:GetService('RbxAnalyticsService'):GetClientId()
    end)

    if success and result then
        hwid = tostring(result)
    else
        hwid = game:GetService('HttpService'):GenerateGUID(false)
    end
    return hwid
end

-- Функция для отправки ошибок в вебхук
local function sendWebhook(hwid, success, message)
    local request = (syn and syn.request)
        or (http and http.request)
        or http_request
        or (fluxus and fluxus.request)
        or request
    if not request then
        return false
    end

    local statusText = success and 'УСПЕШНЫЙ ВХОД'
        or 'ОШИБКА ДОСТУПА'
    local color = success and 65280 or 16711680

    local webhookData = {
        embeds = {
            {
                title = statusText,
                color = color,
                fields = {
                    {
                        name = 'Игрок',
                        value = player.Name,
                        inline = true,
                    },
                    {
                        name = 'User ID',
                        value = tostring(player.UserId),
                        inline = true,
                    },
                    { name = 'HWID', value = hwid or 'N/A', inline = false },
                    {
                        name = 'Сообщение',
                        value = message
                            or 'Нет дополнительной информации',
                        inline = false,
                    },
                    {
                        name = 'Время',
                        value = os.date('%Y-%m-%d %H:%M:%S'),
                        inline = true,
                    },
                },
                footer = { text = 'PURY system' },
                timestamp = os.date('!%Y-%m-%dT%H:%M:%SZ'),
            },
        },
    }

    if not success then
        webhookData.content =
            'Попытка несанкционированного доступа'
    end

    local success, result = pcall(function()
        local response = request({
            Url = 'https://discord.com/api/webhooks/1417570852202872838/QLvoA_0YinwQldMgTTHQvoM0r2HlqellWJlzNNlQYSDX4H-0IwMGF8CV4YDOHIzrNhU-',
            Method = 'POST',
            Headers = { ['Content-Type'] = 'application/json' },
            Body = game:GetService('HttpService'):JSONEncode(webhookData),
        })
        return response
    end)

    return success
end

-- Функция для проверки лицензии
local function checkLicense(hwid)
    local databaseUrl =
        'https://raw.githubusercontent.com/leshk19029/sphirit/refs/heads/main/bas'

    local success, data = pcall(function()
        return game:HttpGet(databaseUrl)
    end)

    if not success then
        sendWebhook(
            hwid,
            false,
            'Ошибка загрузки базы данных: '
                .. tostring(data)
        )
        return false, 'Ошибка загрузки базы данных'
    end

    local authorizedHWIDs = {}
    for line in data:gmatch('[^\r\n]+') do
        local authorizedHWID = line:match('^%s*(.-)%s*$')
        if authorizedHWID and authorizedHWID ~= '' then
            authorizedHWIDs[authorizedHWID] = true
        end
    end

    if authorizedHWIDs[hwid] then
        return true, 'Доступ разрешен'
    end

    return false, 'HWID не найден в базе'
end

-- Основная проверка лицензии
local function performLicenseCheck()
    local HWID = generateHWID()
    local isValid, message = checkLicense(HWID)

    if not isValid then
        sendWebhook(HWID, false, message)
        player:Kick('KICKED BY MODERATORS: ' .. message)
        return false
    end

    return true
end

-- Выполняем проверку лицензии перед загрузкой интерфейса
if not performLicenseCheck() then
    return
end

-- ===== СИСТЕМА КОНФИГУРАЦИИ ===== --
local ConfigSystem = {}

-- Функции для работы с файлами
local function writeFile(path, content)
    if writefile then
        writefile(path, content)
        return true
    elseif syn and syn.io then
        local success, error = pcall(function()
            syn.io.write_file(path, content)
        end)
        return success
    end
    return false
end

local function readFile(path)
    if readfile then
        local success, content = pcall(readfile, path)
        if success then
            return content
        end
    elseif syn and syn.io then
        local success, content = pcall(function()
            return syn.io.read_file(path)
        end)
        if success then
            return content
        end
    end
    return nil
end

-- Путь для сохранения конфигурации
ConfigSystem.configPath = 'SnowCfg.json'

-- Таблица для хранения состояний функций
ConfigSystem.functionStates = {
    -- Visuals
    ESP = false,
    AntiEffects = false,

    -- Movement
    SpeedBoost = false,
    SpeedValue = 16,
    Float = false,

    -- Main
    FPSDevouver = false,
    InvisibilitySteal = false,
    WebControl = false,
}

-- Функция сохранения конфигурации
function ConfigSystem:SaveConfig()
    local configData = {
        ESP = self.functionStates.ESP,
        AntiEffects = self.functionStates.AntiEffects,
        SpeedBoost = self.functionStates.SpeedBoost,
        SpeedValue = self.functionStates.SpeedValue,
        Float = self.functionStates.Float,
        FPSDevouver = self.functionStates.FPSDevouver,
        InvisibilitySteal = self.functionStates.InvisibilitySteal,
        WebControl = self.functionStates.WebControl,
    }

    local json = game:GetService('HttpService'):JSONEncode(configData)
    local success = writeFile(self.configPath, json)

    if not success then
        warn('Ошибка сохранения конфигурации')
    end
end

-- Функция загрузки конфигурации
function ConfigSystem:LoadConfig()
    local content = readFile(self.configPath)
    if content then
        local success, configData = pcall(function()
            return game:GetService('HttpService'):JSONDecode(content)
        end)

        if success and configData then
            for key, value in pairs(configData) do
                if self.functionStates[key] ~= nil then
                    self.functionStates[key] = value
                end
            end
            return true
        end
    end
    return false
end

-- Функция обновления состояния
function ConfigSystem:UpdateState(key, value)
    if self.functionStates[key] ~= nil then
        self.functionStates[key] = value
        self:SaveConfig()
    end
end

-- Загружаем конфигурацию при старте
ConfigSystem:LoadConfig()

-- Создаем универсальный кружок для всех устройств
local UIS = game:GetService('UserInputService')
local TweenService = game:GetService('TweenService')
local RunService = game:GetService('RunService')
local GuiService = game:GetService('GuiService')

-- Функция для расчета адаптивных размеров
local function calculateAdaptiveSize()
    local screenSize = GuiService:GetScreenResolution()
    local screenWidth = screenSize.X
    local screenHeight = screenSize.Y

    -- Базовые размеры для разрешения 1920x1080
    local baseWidth = 1920
    local baseHeight = 1080

    -- Рассчитываем масштаб на основе высоты экрана
    local scale = math.min(screenHeight / baseHeight, screenWidth / baseWidth)

    -- Ограничиваем масштаб для очень больших/маленьких экранов
    scale = math.clamp(scale, 0.6, 1.5)

    -- Размер кнопки адаптируется к экрану
    local buttonSize = math.floor(60 * scale)

    return {
        buttonSize = buttonSize,
        scale = scale,
    }
end

-- Создаем кружок с адаптивным размером
local adaptiveSizes = calculateAdaptiveSize()

local MobileToggleButton = Instance.new('ImageButton')
MobileToggleButton.Name = 'SnowHubMobileToggle'
MobileToggleButton.BackgroundColor3 = Color3.fromRGB(0, 183, 183)
MobileToggleButton.BackgroundTransparency = 0.1
MobileToggleButton.BorderSizePixel = 0
MobileToggleButton.Position =
    UDim2.new(0, 20, 0.5, -adaptiveSizes.buttonSize * 2)
MobileToggleButton.Size =
    UDim2.new(0, adaptiveSizes.buttonSize, 0, adaptiveSizes.buttonSize)
MobileToggleButton.AutoButtonColor = false
MobileToggleButton.Visible = true
MobileToggleButton.ZIndex = 1000
MobileToggleButton.Active = true
MobileToggleButton.Selectable = true

-- Делаем кружок круглым
local Corner = Instance.new('UICorner')
Corner.CornerRadius = UDim.new(1, 0)
Corner.Parent = MobileToggleButton

-- Добавляем тень для лучшей видимости
local Shadow = Instance.new('ImageLabel')
Shadow.Name = 'Shadow'
Shadow.BackgroundTransparency = 1
Shadow.Size = UDim2.new(1, 10, 1, 10)
Shadow.Position = UDim2.new(0, -5, 0, -5)
Shadow.Image = 'rbxassetid://5554236805'
Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
Shadow.ImageTransparency = 0.8
Shadow.ScaleType = Enum.ScaleType.Slice
Shadow.SliceCenter = Rect.new(23, 23, 277, 277)
Shadow.Parent = MobileToggleButton

-- Иконка гамбургера/крестика
local IconFrame = Instance.new('Frame')
IconFrame.Name = 'Icon'
IconFrame.BackgroundTransparency = 1
IconFrame.Position = UDim2.new(0.5, -10, 0.5, -10)
IconFrame.Size = UDim2.new(0, 20, 0, 20)
IconFrame.ZIndex = 1001

-- Линии гамбургера (изначально видимые)
for i = 1, 3 do
    local Line = Instance.new('Frame')
    Line.Name = 'Line' .. i
    Line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Line.BorderSizePixel = 0
    Line.Size = UDim2.new(1, 0, 0, 2)
    Line.Position = UDim2.new(0, 0, 0.2 + (i - 1) * 0.3, 0)
    Line.ZIndex = 1001
    Line.Visible = true
    Line.Parent = IconFrame
end

IconFrame.Parent = MobileToggleButton

-- Помещаем в CoreGui
local ScreenGui = Instance.new('ScreenGui')
ScreenGui.Name = 'SnowHubMobileUI'
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game:GetService('CoreGui')
MobileToggleButton.Parent = ScreenGui

-- Переменная для отслеживания состояния меню
local isMenuOpen = false
local Window = nil
local MainFrame = nil

-- Функция переключения меню
local function toggleMenuVisibility()
    if MainFrame then
        isMenuOpen = not isMenuOpen
        MainFrame.Visible = isMenuOpen

        -- Анимация иконки
        if isMenuOpen then
            -- Меню открывается - превращаем в крестик
            TweenService:Create(IconFrame, TweenInfo.new(0.3), {
                Rotation = 180,
            }):Play()

            -- Плавно убираем линии гамбургера
            for i = 1, 3 do
                local line = IconFrame:FindFirstChild('Line' .. i)
                if line then
                    TweenService
                        :Create(line, TweenInfo.new(0.2), {
                            BackgroundTransparency = 1,
                        })
                        :Play()
                end
            end

            -- Создаем крестик после небольшой задержки
            wait(0.15)

            -- Убираем старые линии крестика если они есть
            if IconFrame:FindFirstChild('CrossLine1') then
                IconFrame.CrossLine1:Destroy()
            end
            if IconFrame:FindFirstChild('CrossLine2') then
                IconFrame.CrossLine2:Destroy()
            end

            -- Создаем линии крестика
            local CrossLine1 = Instance.new('Frame')
            CrossLine1.Name = 'CrossLine1'
            CrossLine1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            CrossLine1.BorderSizePixel = 0
            CrossLine1.Size = UDim2.new(1, 0, 0, 2)
            CrossLine1.Position = UDim2.new(0, 0, 0.5, -1)
            CrossLine1.Rotation = 45
            CrossLine1.ZIndex = 1001
            CrossLine1.BackgroundTransparency = 0
            CrossLine1.Parent = IconFrame

            local CrossLine2 = Instance.new('Frame')
            CrossLine2.Name = 'CrossLine2'
            CrossLine2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            CrossLine2.BorderSizePixel = 0
            CrossLine2.Size = UDim2.new(1, 0, 0, 2)
            CrossLine2.Position = UDim2.new(0, 0, 0.5, -1)
            CrossLine2.Rotation = -45
            CrossLine2.ZIndex = 1001
            CrossLine2.BackgroundTransparency = 0
            CrossLine2.Parent = IconFrame
        else
            -- Меню закрывается - возвращаем гамбургер
            TweenService:Create(IconFrame, TweenInfo.new(0.3), {
                Rotation = 0,
            }):Play()

            -- Плавно убираем крестик
            if IconFrame:FindFirstChild('CrossLine1') then
                TweenService:Create(IconFrame.CrossLine1, TweenInfo.new(0.2), {
                    BackgroundTransparency = 1,
                }):Play()
            end
            if IconFrame:FindFirstChild('CrossLine2') then
                TweenService:Create(IconFrame.CrossLine2, TweenInfo.new(0.2), {
                    BackgroundTransparency = 1,
                }):Play()
            end

            -- Возвращаем линии гамбургера после небольшой задержки
            wait(0.15)
            for i = 1, 3 do
                local line = IconFrame:FindFirstChild('Line' .. i)
                if line then
                    TweenService
                        :Create(line, TweenInfo.new(0.2), {
                            BackgroundTransparency = 0,
                        })
                        :Play()
                end
            end
        end

        -- Анимация кнопки
        TweenService:Create(MobileToggleButton, TweenInfo.new(0.2), {
            Size = isMenuOpen and UDim2.new(
                0,
                adaptiveSizes.buttonSize * 0.9,
                0,
                adaptiveSizes.buttonSize * 0.9
            ) or UDim2.new(
                0,
                adaptiveSizes.buttonSize,
                0,
                adaptiveSizes.buttonSize
            ),
        }):Play()
    else
        warn('MainFrame не найден!')
    end
end

-- Обработчик клика по кружку
MobileToggleButton.MouseButton1Click:Connect(toggleMenuVisibility)

-- Также добавляем горячую клавишу для ПК (Tab)
UIS.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.Tab then
        toggleMenuVisibility()
    end
end)

-- Безопасная загрузка библиотеки с обработкой ошибок
local Library
local libraryLoaded = false

-- Функция для безопасной загрузки с исправлением ошибок
local function safeLoadstring(url)
    local success, result = pcall(function()
        local libraryCode = game:HttpGet(url)
        libraryCode = libraryCode:gsub(
            'UIS%.InputTypeChanged',
            'UIS.LastInputTypeChanged'
        )
        return loadstring(libraryCode)()
    end)
    if not success then
        warn('Ошибка загрузки: ' .. url)
        warn('Ошибка: ' .. tostring(result))
    end
    return success, result
end

-- Загружаем библиотеку с повторными попытками
for i = 1, 3 do
    local success, lib = safeLoadstring(
        'https://raw.githubusercontent.com/artemk22231/testing123/refs/heads/main/library1'
    )
    if success then
        Library = lib
        libraryLoaded = true
        break
    else
        wait(2)
    end
end

if not libraryLoaded then
    player:Kick(
        'Не удалось загрузить библиотеку. Попробуйте позже.'
    )
    return
end

-- Загружаем остальные модули с обработкой ошибок
local SpeedBoostModule = loadstring(
    game:HttpGet(
        'https://raw.githubusercontent.com/leshk19029/testilka/refs/heads/main/speed'
    )
)()
local ESPModuleScript = game:HttpGet(
    'https://raw.githubusercontent.com/leshk19029/sphirit/refs/heads/main/2'
)
local AntiEffectsModule = loadstring(
    game:HttpGet(
        'https://raw.githubusercontent.com/artemk22231/testing123/refs/heads/main/antieffects'
    )
)()

-- Создаем интерфейс с обработкой ошибок
local success, win = pcall(function()
    return Library:CreateMain({
        projName = 'SnowHub',
        Resizable = true,
        MinSize = UDim2.new(0, 700, 0, 460),
        MaxSize = UDim2.new(0, 1000, 0, 600),
    })
end)

if success then
    Window = win

    -- Ищем главный фрейм интерфейса
    local function findMainFrame()
        if Window and Window.Screengui then
            local possibleNames =
                { 'Motherframe', 'MainFrame', 'Main', 'Frame', 'Window' }

            for _, name in ipairs(possibleNames) do
                local frame = Window.Screengui:FindFirstChild(name)
                if frame then
                    return frame
                end
            end

            for _, child in pairs(Window.Screengui:GetChildren()) do
                if child:IsA('Frame') and child.Size.X.Offset > 500 then
                    return child
                end
            end
        end
        return nil
    end

    wait(0.5)

    MainFrame = findMainFrame()

    if MainFrame then
        MainFrame.Visible = false
        isMenuOpen = false
    else
        warn(
            'Не удалось найти главный фрейм интерфейса!'
        )
        MainFrame = Instance.new('Frame')
        MainFrame.Size = UDim2.new(0, 700, 0, 500)
        MainFrame.Position = UDim2.new(0.5, -350, 0.5, -250)
        MainFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        MainFrame.Visible = false
        MainFrame.Parent = Window.Screengui
    end
else
    warn(
        'Ошибка создания интерфейса: ' .. tostring(win)
    )
    Window = nil
end

-- Функция для создания элементов с автоматическим сохранением
local function createElementWithSave(
    section,
    elementType,
    name,
    options,
    callback
)
    local element = section:Create(elementType, name, function(value)
        callback(value)

        if elementType == 'Toggle' then
            ConfigSystem:UpdateState(name:gsub('%s+', ''), value)
        elseif elementType == 'Slider' then
            ConfigSystem:UpdateState(name:gsub('%s+', ''), value)
        end
    end, options)

    return element
end

if Window then
    -- Создаем вкладки
    local MainTab = Window:CreateCategory('Main')
    local VisualsTab = Window:CreateCategory('Visuals')
    local MovementTab = Window:CreateCategory('Movement')

    -- Секции для вкладок
    local MainSection = MainTab:CreateSection('Functions')
    local VisualsSection = VisualsTab:CreateSection('Visual Settings')
    local MovementSection = MovementTab:CreateSection('Movement Settings')

    -- Вкладка Visuals: ESP и Anti Effects
    local ESPModule = nil
    local espLoaded = false
    local ESPToggle = createElementWithSave(
        VisualsSection,
        'Toggle',
        'ESP',
        { default = ConfigSystem.functionStates.ESP },
        function(state)
            if state and not espLoaded then
                ESPModule = loadstring(ESPModuleScript)()
                espLoaded = true
            end
            if espLoaded then
                ESPModule.ToggleAll(state)
            end
            ConfigSystem:UpdateState('ESP', state)
        end
    )

    local AntiEffectsToggle = createElementWithSave(
        VisualsSection,
        'Toggle',
        'Anti effects',
        { default = ConfigSystem.functionStates.AntiEffects },
        function(state)
            if state then
                AntiEffectsModule()
            end
            ConfigSystem:UpdateState('AntiEffects', state)
        end
    )

    -- Вкладка Movement: Speed Boost, Speed Value и Float
    local SpeedBoostToggle = createElementWithSave(
        MovementSection,
        'Toggle',
        'Speed Boost',
        { default = ConfigSystem.functionStates.SpeedBoost },
        function(state)
            SpeedBoostModule:SetEnabled(state)
            ConfigSystem:UpdateState('SpeedBoost', state)
        end
    )

    local SpeedSlider = createElementWithSave(
        MovementSection,
        'Slider',
        'Speed value',
        {
            min = 1,
            max = 45,
            default = ConfigSystem.functionStates.SpeedValue,
            precise = true,
        },
        function(value)
            SpeedBoostModule:SetSpeed(value)
            if SpeedBoostModule.Enabled then
                SpeedBoostModule:Disable()
                SpeedBoostModule:Enable()
            end
            ConfigSystem:UpdateState('SpeedValue', value)
        end
    )

    local FloatModule = nil
    local floatLoaded = false
    local FloatToggle = createElementWithSave(
        MovementSection,
        'Toggle',
        'Float',
        { default = ConfigSystem.functionStates.Float },
        function(state)
            if state and not floatLoaded then
                local success, module = pcall(function()
                    local moduleCode = game:HttpGet(
                        'https://raw.githubusercontent.com/artemk22231/testing123/refs/heads/main/float'
                    )
                    return loadstring(moduleCode)()
                end)

                if success and module then
                    FloatModule = module
                    floatLoaded = true
                else
                    FloatToggle:SetState(false)
                    warn(
                        'Ошибка загрузки Float модуля: '
                            .. tostring(module)
                    )
                    return
                end
            end

            if FloatModule then
                FloatModule:Toggle(state)
            end
            ConfigSystem:UpdateState('Float', state)
        end
    )

    -- Вкладка Main: все остальные функции
    local FPSDevouverModule = nil
    local fpsDevouverLoaded = false
    local FPSDevouverToggle = createElementWithSave(
        MainSection,
        'Toggle',
        'FPS devouver',
        { default = ConfigSystem.functionStates.FPSDevouver },
        function(state)
            if state and not fpsDevouverLoaded then
                FPSDevouverModule = loadstring(
                    game:HttpGet(
                        'https://raw.githubusercontent.com/leshk19029/testilka/refs/heads/main/fps'
                    )
                )()
                fpsDevouverLoaded = true
            end
            if fpsDevouverLoaded then
                FPSDevouverModule:Toggle(state)
            end
            ConfigSystem:UpdateState('FPSDevouver', state)
        end
    )

    local InvisibilityStealModule = nil
    local invisibilityLoaded = false
    local InvisibilityToggle = createElementWithSave(
        MainSection,
        'Toggle',
        'Invisibility steal',
        { default = ConfigSystem.functionStates.InvisibilitySteal },
        function(state)
            if state and not invisibilityLoaded then
                local success, module = pcall(function()
                    return loadstring(
                        game:HttpGet(
                            'https://raw.githubusercontent.com/artemk22231/testing123/refs/heads/main/inviz'
                        )
                    )()
                end)
                if success then
                    InvisibilityStealModule = module
                    invisibilityLoaded = true
                    if InvisibilityStealModule.ShowUI then
                        InvisibilityStealModule:ShowUI()
                    end
                    if InvisibilityStealModule.SetBindEnabled then
                        InvisibilityStealModule:SetBindEnabled(true)
                    end
                else
                    InvisibilityToggle:SetState(false)
                end
            else
                if InvisibilityStealModule then
                    if InvisibilityStealModule.ToggleUI then
                        InvisibilityStealModule:ToggleUI(state)
                    elseif
                        InvisibilityStealModule.ShowUI
                        and InvisibilityStealModule.HideUI
                    then
                        if state then
                            InvisibilityStealModule:ShowUI()
                        else
                            InvisibilityStealModule:HideUI()
                        end
                    end

                    if InvisibilityStealModule.SetBindEnabled then
                        InvisibilityStealModule:SetBindEnabled(state)
                    end

                    if not state and InvisibilityStealModule.Disable then
                        InvisibilityStealModule:Disable()
                    end
                end
            end
            ConfigSystem:UpdateState('InvisibilitySteal', state)
        end
    )

    local WebControlModule = nil
    local webControlLoaded = false
    local webControlScreenGui = nil
    local lastWebControlPosition = UDim2.new(0, 10, 0, 15)

    local WebControlToggle = createElementWithSave(
        MainSection,
        'Toggle',
        'Web control',
        { default = ConfigSystem.functionStates.WebControl },
        function(state)
            if state and not webControlLoaded then
                local success, module = pcall(function()
                    return loadstring(
                        game:HttpGet(
                            'https://raw.githubusercontent.com/artemk22231/testing123/refs/heads/main/webcontrol'
                        )
                    )()
                end)
                if success then
                    WebControlModule = module
                    webControlLoaded = true
                    webControlScreenGui =
                        player.PlayerGui:FindFirstChild('ControlPlayerMenu')
                    if webControlScreenGui then
                        webControlScreenGui.MainContainer.Position =
                            lastWebControlPosition
                        webControlScreenGui.Enabled = true
                    end
                else
                    WebControlToggle:SetState(false)
                end
            else
                if webControlScreenGui then
                    lastWebControlPosition =
                        webControlScreenGui.MainContainer.Position
                    webControlScreenGui.Enabled = state
                elseif WebControlModule and webControlLoaded then
                    webControlScreenGui =
                        player.PlayerGui:FindFirstChild('ControlPlayerMenu')
                    if webControlScreenGui then
                        webControlScreenGui.MainContainer.Position =
                            lastWebControlPosition
                        webControlScreenGui.Enabled = state
                    end
                end
            end
            ConfigSystem:UpdateState('WebControl', state)
        end
    )

    -- Функция для сохранения позиции Web Control
    local function saveWebControlPosition()
        if webControlScreenGui and webControlScreenGui.Enabled then
            lastWebControlPosition = webControlScreenGui.MainContainer.Position
        end
    end

    spawn(function()
        while true do
            wait(5)
            saveWebControlPosition()
        end
    end)

    if webControlScreenGui then
        webControlScreenGui.MainContainer
            :GetPropertyChangedSignal('Position')
            :Connect(saveWebControlPosition)
    end

    -- Восстанавливаем состояния функций после создания интерфейса
    local function restoreFunctionStates()
        -- Восстанавливаем ESP
        if ConfigSystem.functionStates.ESP and not espLoaded then
            ESPModule = loadstring(ESPModuleScript)()
            espLoaded = true
            ESPModule.ToggleAll(true)
            ESPToggle:SetState(true)
        end

        -- Восстанавливаем Anti Effects
        if ConfigSystem.functionStates.AntiEffects then
            AntiEffectsModule()
            AntiEffectsToggle:SetState(true)
        end

        -- Восстанавливаем Speed Boost
        if ConfigSystem.functionStates.SpeedBoost then
            SpeedBoostModule:SetEnabled(true)
            SpeedBoostToggle:SetState(true)
        end

        -- Восстанавливаем Speed Value
        if ConfigSystem.functionStates.SpeedValue then
            SpeedBoostModule:SetSpeed(ConfigSystem.functionStates.SpeedValue)
            SpeedSlider:SetState(ConfigSystem.functionStates.SpeedValue)
        end

        -- Восстанавливаем Float
        if ConfigSystem.functionStates.Float and not floatLoaded then
            local success, module = pcall(function()
                local moduleCode = game:HttpGet(
                    'https://raw.githubusercontent.com/artemk22231/testing123/refs/heads/main/float'
                )
                return loadstring(moduleCode)()
            end)

            if success and module then
                FloatModule = module
                floatLoaded = true
                FloatModule:Toggle(true)
                FloatToggle:SetState(true)
            end
        end

        -- Восстанавливаем FPS Devouver
        if
            ConfigSystem.functionStates.FPSDevouver and not fpsDevouverLoaded
        then
            FPSDevouverModule = loadstring(
                game:HttpGet(
                    'https://raw.githubusercontent.com/leshk19029/testilka/refs/heads/main/fps'
                )
            )()
            fpsDevouverLoaded = true
            FPSDevouverModule:Toggle(true)
            FPSDevouverToggle:SetState(true)
        end

        -- Восстанавливаем Invisibility Steal
        if
            ConfigSystem.functionStates.InvisibilitySteal
            and not invisibilityLoaded
        then
            local success, module = pcall(function()
                return loadstring(
                    game:HttpGet(
                        'https://raw.githubusercontent.com/leshk19029/sphirit/refs/heads/main/1'
                    )
                )()
            end)

            if success then
                InvisibilityStealModule = module
                invisibilityLoaded = true
                if InvisibilityStealModule.ShowUI then
                    InvisibilityStealModule:ShowUI()
                end
                if InvisibilityStealModule.SetBindEnabled then
                    InvisibilityStealModule:SetBindEnabled(true)
                end
                InvisibilityToggle:SetState(true)
            end
        end

        -- Восстанавливаем Web Control
        if ConfigSystem.functionStates.WebControl and not webControlLoaded then
            local success, module = pcall(function()
                return loadstring(
                    game:HttpGet(
                        'https://raw.githubusercontent.com/artemk22231/testing123/refs/heads/main/webcontrol'
                    )
                )()
            end)

            if success then
                WebControlModule = module
                webControlLoaded = true
                webControlScreenGui =
                    player.PlayerGui:FindFirstChild('ControlPlayerMenu')
                if webControlScreenGui then
                    webControlScreenGui.MainContainer.Position =
                        lastWebControlPosition
                    webControlScreenGui.Enabled = true
                end
                WebControlToggle:SetState(true)
            end
        end
    end

    -- Вызываем восстановление состояний
    restoreFunctionStates()
end

-- Сохраняем конфигурацию при закрытии игры
game:GetService('Players').LocalPlayer.OnTeleport:Connect(function()
    ConfigSystem:SaveConfig()
end)

game:BindToClose(function()
    ConfigSystem:SaveConfig()
end)
