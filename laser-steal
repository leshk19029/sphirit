local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local Event = game:GetService('ReplicatedStorage').Packages.Net['RE/UseItem']

local player = Players.LocalPlayer
local isFiring = false
local fireRate = 30 -- Значение по умолчанию
local fireInterval = 1 / fireRate
local lastFireTime = 0
local equipConnection = nil
local spamConnection = nil
local spawnLoopRunning = false

-- Функция для безопасного получения персонажа
local function getCharacter(p)
    if p and p.Character then
        return p.Character
    end
    warn('Нет персонажа для игрока: ' .. p.Name)
    return nil
end

-- Функция для поиска ближайшего игрока
local function getClosestPlayer()
    local localCharacter = getCharacter(player)
    if not localCharacter or not localCharacter:FindFirstChild('HumanoidRootPart') then
        warn('Локальный игрок не имеет персонажа или HumanoidRootPart')
        return nil
    end

    local localRoot = localCharacter.HumanoidRootPart
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player then
            local character = getCharacter(p)
            if character and character:FindFirstChild('HumanoidRootPart') and character:FindFirstChild('UpperTorso') then
                local distance = (localRoot.Position - character.HumanoidRootPart.Position).Magnitude
                warn('Игрок: ' .. p.Name .. ', расстояние: ' .. tostring(distance))
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = character
                end
            else
                warn('Игрок ' .. p.Name .. ' не имеет персонажа, HumanoidRootPart или UpperTorso')
            end
        end
    end

    if closestPlayer then
        warn('Найден ближайший игрок: ' .. closestPlayer.Parent.Name .. ', расстояние: ' .. tostring(closestDistance))
        return closestPlayer
    else
        warn('Ближайший игрок не найден')
        return nil
    end
end

-- Функция для спама ивентами
local function spamEvent()
    local targetCharacter = getClosestPlayer()
    if targetCharacter and targetCharacter:FindFirstChild('UpperTorso') then
        local targetPosition = targetCharacter.UpperTorso.Position
        local success, errorMsg = pcall(function()
            Event:FireServer(
                targetPosition, -- Позиция UpperTorso цели
                targetCharacter.UpperTorso
            )
        end)

        if success then
            warn('Успешно отправлен FireServer для игрока: ' .. targetCharacter.Parent.Name)
        else
            warn('Ошибка при вызове FireServer: ' .. tostring(errorMsg))
        end
    else
        warn('Нет цели или UpperTorso для spamEvent')
    end
end

-- Функция для взятия Laser Cape
local function takeLaserCape()
    local backpack = player:FindFirstChild('Backpack')
    if not backpack then
        warn('Backpack не найден')
        return false
    end

    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA('Tool') and (tool.Name:lower():find('laser') and tool.Name:lower():find('cape')) then
            local character = player.Character
            if character then
                local humanoid = character:FindFirstChild('Humanoid')
                if humanoid then
                    humanoid:EquipTool(tool)
                    warn('Экипирован Laser Cape: ' .. tool.Name)
                    return true
                else
                    warn('Humanoid не найден в персонаже')
                end
            else
                warn('Персонаж не найден для экипировки')
            end
        end
    end
    warn('Laser Cape не найден в Backpack')
    return false
end

-- Запуск авто-экипировки
local function startAutoEquip()
    if equipConnection then
        equipConnection:Disconnect()
    end

    equipConnection = RunService.Heartbeat:Connect(function()
        local character = player.Character
        if character then
            local hasLaserCape = false
            for _, tool in ipairs(character:GetChildren()) do
                if tool:IsA('Tool') and (tool.Name:lower():find('laser') and tool.Name:lower():find('cape')) then
                    hasLaserCape = true
                    break
                end
            end

            if not hasLaserCape then
                takeLaserCape()
            end
        else
            warn('Персонаж отсутствует для авто-экипировки')
        end
    end)

    return function()
        if equipConnection then
            equipConnection:Disconnect()
            equipConnection = nil
        end
    end
end

-- Основной цикл для спама
local function startItemSpam(rate)
    if rate then
        fireRate = math.clamp(rate, 10, 60)
        fireInterval = 1 / fireRate
        warn('Установлена частота спама: ' .. tostring(fireRate) .. ' Гц')
    end
    isFiring = true

    -- Heartbeat цикл
    if spamConnection then
        spamConnection:Disconnect()
    end
    spamConnection = RunService.Heartbeat:Connect(function()
        if not isFiring then
            spamConnection:Disconnect()
            spamConnection = nil
            return
        end

        local currentTime = tick()
        if currentTime - lastFireTime >= fireInterval then
            lastFireTime = currentTime
            spamEvent()
        end
    end)

    -- Spawn цикл для надежности
    if not spawnLoopRunning then
        spawnLoopRunning = true
        spawn(function()
            while spawnLoopRunning and isFiring do
                spamEvent()
                wait(fireInterval)
            end
            spawnLoopRunning = false
        end)
    end

    return function()
        isFiring = false
        if spamConnection then
            spamConnection:Disconnect()
            spamConnection = nil
        end
        spawnLoopRunning = false
        warn('Спам остановлен')
    end
end

-- Экспортируем функции
return {
    startItemSpam = startItemSpam,
    startAutoEquip = startAutoEquip,
    spamEvent = spamEvent,
    takeLaserCape = takeLaserCape
}
